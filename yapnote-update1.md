### ./YapNotes/Models/CoreData/NoteCategoryModel.swift

import Foundation
import CoreData
import SwiftUI

extension NoteCategory {
    // Extension to provide convenience methods and computed properties
    
    var thoughtsArray: [Thought] {
        let set = thoughts as? Set<Thought> ?? []
        return Array(set).sorted { ($0.createdAt ?? Date()) > ($1.createdAt ?? Date()) }
    }
    
    var color: Color {
        Color(hex: colorHex ?? "#4A90E2")
    }
    
    // Create a new NoteCategory
    static func create(in context: NSManagedObjectContext,
                       name: String,
                       colorHex: String,
                       isAutoGenerated: Bool = false) -> NoteCategory {
        let noteCategory = NoteCategory(context: context)
        noteCategory.uuid = UUID()
        noteCategory.name = name
        noteCategory.colorHex = colorHex
        noteCategory.isAutoGenerated = isAutoGenerated
        
        return noteCategory
    }
    
    // Predefined category colors
    static let predefinedColors = [
        "#4A90E2", // Blue
        "#D64545", // Red
        "#50E3C2", // Teal
        "#F5A623", // Orange
        "#7ED321", // Green
        "#BD10E0", // Purple
        "#9013FE", // Violet
        "#4A4A4A", // Dark Gray
        "#8B572A", // Brown
        "#B8E986"  // Light Green
    ]
    
    // Get a random color for auto-generated categories
    static func randomColor() -> String {
        predefinedColors.randomElement() ?? "#4A90E2"
    }
}

// Helper extension for Color from hex
extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int >> 8) * 17,
                            (int >> 4 & 0xF) * 17,
                            (int & 0xF) * 17)
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255,
                            int >> 16,
                            int >> 8 & 0xFF,
                            int & 0xFF)
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int >> 24,
                            int >> 16 & 0xFF,
                            int >> 8 & 0xFF,
                            int & 0xFF)
        default:
            (a, r, g, b) = (255, 0, 0, 0)
        }
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue: Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}

### ./YapNotes/Services/OrganizationService.swift

import Foundation
import CoreData
import NaturalLanguage

/// A custom struct to hold entity info (since NLEntity doesn't exist in Apple's API)
struct NLEntity {
    let string: String
    let range: Range<String.Index>
    let type: NLTag
}

class OrganizationService {
    static let shared = OrganizationService()
    
    private let modelManager = MLModelManager.shared
    private let mobileBERTService = MobileBERTService.shared
    private let miniLMService = MiniLMService.shared
    
    private init() {}
    
    /// Called when a new Thought is saved, to do background classification, embeddings, relationships, etc.
    func processNewThought(_ thought: Thought) async throws {
        // Get managed object context
        guard let context = thought.managedObjectContext else {
            throw NSError(domain: "OrganizationService",
                          code: 1,
                          userInfo: [NSLocalizedDescriptionKey: "No managed object context for thought"])
        }
        
        // Process in the correct context
        try await context.perform {
            // 1. Extract entities and key concepts
            let entities = try await self.extractEntities(from: thought.transcription ?? "")
            
            // 2. Generate embeddings for semantic similarity
            if let embeddings = try await self.generateEmbeddings(for: thought.transcription ?? "") {
                thought.embeddings = embeddings
            }
            
            // 3. Auto-generate tags
            let tags = entities.map { $0.string }
            thought.addTags(tags)
            
            // 4. Suggest categories
            let suggestedCategories = try await self.suggestCategories(for: thought.transcription ?? "")
            
            // 5. Find related thoughts
            let relatedThoughts = try await self.findRelatedThoughts(for: thought)
            
            // 6. Apply auto-created categories
            try self.applyAutoCategories(thought, suggestions: suggestedCategories)
            
            // 7. Create relationships with related thoughts
            for relatedThought in relatedThoughts {
                thought.addToRelatedThoughts(relatedThought)
                relatedThought.addToRelatedThoughts(thought)
            }
        }
    }
    
    /// Process an existing Thought to get category suggestions and related thoughts (used by OrganizationViewModel).
    func processThought(_ thought: Thought,
                        in context: NSManagedObjectContext)
    async throws -> ([CategorySuggestion], [Thought]) {
        
        // 1. Extract entities from text
        let entities = try await extractEntities(from: thought.transcription ?? "")
        
        // 2. Generate embeddings if needed
        if thought.embeddings == nil {
            if let embeddings = try await generateEmbeddings(for: thought.transcription ?? "") {
                await context.perform {
                    thought.embeddings = embeddings
                }
            }
        }
        
        // 3. Suggest categories
        let categorySuggestions = try await suggestCategoriesWithExistingCheck(
            for: thought.transcription ?? "",
            in: context
        )
        
        // 4. Find related thoughts
        let relatedThoughts = try await findRelatedThoughts(for: thought)
        
        return (categorySuggestions, relatedThoughts)
    }
    
    // MARK: - Entity Extraction
    
    func extractEntities(from text: String) async throws -> [NLEntity] {
        let tagger = NLTagger(tagSchemes: [.nameType])
        tagger.string = text
        
        var entities: [NLEntity] = []
        
        let options: NLTagger.Options = [.omitPunctuation, .omitWhitespace, .joinNames]
        let tags: [NLTag] = [.personalName, .placeName, .organizationName]
        
        tagger.enumerateTags(in: text.startIndex..<text.endIndex,
                             unit: .word,
                             scheme: .nameType,
                             options: options) { tag, tokenRange in
            if let tag = tag, tags.contains(tag) {
                let entity = NLEntity(
                    string: String(text[tokenRange]),
                    range: tokenRange,
                    type: tag
                )
                entities.append(entity)
            }
            return true
        }
        
        // Use MobileBERT for more advanced entity extraction if available
        if modelManager.isModelLoaded(.mobileBERT) {
            let bertEntities = try await mobileBERTService.extractEntities(from: text)
            entities.append(contentsOf: bertEntities)
        }
        
        return entities
    }
    
    // MARK: - Embedding Generation
    
    func generateEmbeddings(for text: String) async throws -> Data? {
        guard !text.isEmpty else { return nil }
        
        // If MiniLM is available, use it for better embeddings
        if modelManager.isModelLoaded(.miniLM) {
            return try await miniLMService.generateEmbeddings(for: text)
        }
        
        // Fallback to NLP embeddings
        let embedding = try await generateNLPEmbeddings(for: text)
        return try NSKeyedArchiver.archivedData(withRootObject: embedding, requiringSecureCoding: true)
    }
    
    private func generateNLPEmbeddings(for text: String) async throws -> [Float] {
        let embedding = NLEmbedding.sentenceEmbedding(for: .english)
        guard let vectorDouble = embedding?.vector(for: text) else {
            throw NSError(domain: "OrganizationService",
                          code: 2,
                          userInfo: [NSLocalizedDescriptionKey: "Failed to generate embeddings"])
        }
        
        // Convert [Double] â†’ [Float]
        let vectorFloat = vectorDouble.map { Float($0) }
        return vectorFloat
    }
    
    // MARK: - Category Suggestion
    
    func suggestCategories(for text: String) async throws -> [(name: String, confidence: Float)] {
        var categories: [(name: String, confidence: Float)] = []
        
        // Use Natural Language for initial categorization
        let tagger = NLTagger(tagSchemes: [.lexicalClass])
        tagger.string = text
        
        // Extract keywords to suggest categories
        var keywordCounts: [String: Int] = [:]
        
        let options: NLTagger.Options = [.omitPunctuation, .omitWhitespace]
        tagger.enumerateTags(in: text.startIndex..<text.endIndex,
                             unit: .word,
                             scheme: .lexicalClass,
                             options: options) { tag, range in
            if let tag = tag, (tag == .noun || tag == .verb) {
                let word = String(text[range]).lowercased()
                if word.count > 3 {
                    keywordCounts[word, default: 0] += 1
                }
            }
            return true
        }
        
        // Generate potential categories from top keywords
        let sortedKeywords = keywordCounts.sorted { $0.value > $1.value }.prefix(5)
        for (keyword, count) in sortedKeywords {
            let confidence = min(Float(count) / 10.0, 1.0)
            categories.append((keyword.capitalized, confidence))
        }
        
        // If MobileBERT is available, use it for better category suggestions
        if modelManager.isModelLoaded(.mobileBERT) {
            let bertCategories = try await mobileBERTService.suggestCategories(for: text)
            categories.append(contentsOf: bertCategories)
        }
        
        // Remove duplicates and sort by confidence
        var uniqueCategories: [(String, Float)] = []
        var seenNames = Set<String>()
        
        for cat in categories.sorted(by: { $0.confidence > $1.confidence }) {
            if !seenNames.contains(cat.name) {
                uniqueCategories.append(cat)
                seenNames.insert(cat.name)
            }
        }
        
        return Array(uniqueCategories.prefix(3))
    }
    
    func suggestCategoriesWithExistingCheck(for text: String,
                                           in context: NSManagedObjectContext)
    async throws -> [CategorySuggestion] {
        // Get suggested categories
        let suggestedCategories = try await suggestCategories(for: text)
        
        // Fetch existing NoteCategory
        let fetchRequest = NSFetchRequest<NoteCategory>(entityName: "NoteCategory")
        fetchRequest.predicate = NSPredicate(format: "name IN %@", suggestedCategories.map { $0.name })
        
        let existingCategories = try await context.perform {
            try context.fetch(fetchRequest)
        }
        
        let existingNames = Set(existingCategories.compactMap { $0.name })
        
        // Create category suggestions with existence check
        return suggestedCategories.map { suggestion in
            CategorySuggestion(
                name: suggestion.name,
                confidence: suggestion.confidence,
                exists: existingNames.contains(suggestion.name)
            )
        }
    }
    
    // MARK: - Related Thoughts
    
    func findRelatedThoughts(for thought: Thought) async throws -> [Thought] {
        guard let embeddings = thought.embeddings,
              let context = thought.managedObjectContext else {
            return []
        }
        
        // Fetch all thoughts except the current one
        let fetchRequest = NSFetchRequest<Thought>(entityName: "Thought")
        fetchRequest.predicate = NSPredicate(format: "uuid != %@", thought.uuid! as CVarArg)
        
        let allThoughts = try await context.perform {
            try context.fetch(fetchRequest)
        }
        
        // Calculate similarity with each thought
        var thoughtsWithSimilarity: [(Thought, Float)] = []
        
        for other in allThoughts {
            guard let otherEmbeddings = other.embeddings else { continue }
            
            let similarity = try await calculateCosineSimilarity(embeddings1: embeddings,
                                                                 embeddings2: otherEmbeddings)
            thoughtsWithSimilarity.append((other, similarity))
        }
        
        // Return top 5
        return thoughtsWithSimilarity
            .sorted(by: { $0.1 > $1.1 })
            .prefix(5)
            .map { $0.0 }
    }
    
    private func calculateCosineSimilarity(embeddings1: Data, embeddings2: Data) async throws -> Float {
        // Load vector from archived data
        let vector1 = try NSKeyedUnarchiver.unarchivedObject(ofClass: NSArray.self, from: embeddings1) as? [Float] ?? []
        let vector2 = try NSKeyedUnarchiver.unarchivedObject(ofClass: NSArray.self, from: embeddings2) as? [Float] ?? []
        
        guard vector1.count == vector2.count, !vector1.isEmpty else {
            return 0
        }
        
        var dotProduct: Float = 0
        var magnitude1: Float = 0
        var magnitude2: Float = 0
        
        for i in 0..<vector1.count {
            dotProduct += vector1[i] * vector2[i]
            magnitude1 += vector1[i] * vector1[i]
            magnitude2 += vector2[i] * vector2[i]
        }
        
        magnitude1 = sqrt(magnitude1)
        magnitude2 = sqrt(magnitude2)
        
        if magnitude1 > 0 && magnitude2 > 0 {
            return dotProduct / (magnitude1 * magnitude2)
        } else {
            return 0
        }
    }
    
    // MARK: - Auto Categorization
    
    private func applyAutoCategories(_ thought: Thought,
                                     suggestions: [(name: String, confidence: Float)]) throws {
        guard let context = thought.managedObjectContext else { return }
        
        // Only apply suggestions with high confidence
        let highConfidence = suggestions.filter { $0.confidence >= 0.7 }
        
        for suggestion in highConfidence {
            // Check if category already exists
            let fetchRequest = NSFetchRequest<NoteCategory>(entityName: "NoteCategory")
            fetchRequest.predicate = NSPredicate(format: "name == %@", suggestion.name)
            
            let existing = try context.fetch(fetchRequest)
            
            if let cat = existing.first {
                // Add thought to existing NoteCategory
                thought.addToNoteCategories(cat)
            } else {
                // Create new auto-generated category
                let newCat = NoteCategory.create(
                    in: context,
                    name: suggestion.name,
                    colorHex: NoteCategory.randomColor(),
                    isAutoGenerated: true
                )
                thought.addToNoteCategories(newCat)
            }
        }
    }
}

struct CategorySuggestion: Identifiable {
    let id = UUID()
    let name: String
    let confidence: Float
    let exists: Bool
    
    var formattedConfidence: String {
        let percentage = Int(confidence * 100)
        return "\(percentage)%"
    }
}

### ./YapNotes/Views/NoteCategoryView.swift

import SwiftUI
import CoreData

struct NoteCategoryView: View {
    @Environment(\.managedObjectContext) private var viewContext
    
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \NoteCategory.name, ascending: true)],
        animation: .default
    )
    private var categories: FetchedResults<NoteCategory>
    
    @State private var showingAddCategory = false
    @State private var selectedCategory: NoteCategory?
    
    var body: some View {
        ZStack {
            if categories.isEmpty {
                VStack(spacing: 16) {
                    Image(systemName: "tag.fill")
                        .font(.system(size: 50))
                        .foregroundColor(.secondary)
                    
                    Text("No categories yet")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    
                    Text("Categories help you organize your thoughts")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal)
                    
                    Button(action: {
                        showingAddCategory = true
                    }) {
                        Label("Create Category", systemImage: "plus")
                            .padding(.horizontal, 16)
                            .padding(.vertical, 8)
                            .background(Color.accentColor)
                            .foregroundColor(.white)
                            .cornerRadius(8)
                    }
                    .padding(.top, 8)
                }
            } else {
                List {
                    ForEach(categories) { noteCategory in
                        NoteCategoryListItem(noteCategory: noteCategory)
                            .onTapGesture {
                                selectedCategory = noteCategory
                            }
                    }
                    .onDelete(perform: deleteCategories)
                }
            }
        }
        .navigationBarItems(trailing: Button(action: {
            showingAddCategory = true
        }) {
            Image(systemName: "plus")
        })
        .sheet(isPresented: $showingAddCategory) {
            NoteCategoryEditView(mode: .add)
        }
        .sheet(item: $selectedCategory) { category in
            NoteCategoryDetailView(category: category)
        }
    }
    
    private func deleteCategories(offsets: IndexSet) {
        withAnimation {
            offsets.map { categories[$0] }.forEach(viewContext.delete)
            
            do {
                try viewContext.save()
            } catch {
                print("Error deleting categories: \(error.localizedDescription)")
            }
        }
    }
}

struct NoteCategoryListItem: View {
    @ObservedObject var noteCategory: NoteCategory
    
    var body: some View {
        HStack {
            Circle()
                .fill(noteCategory.color)
                .frame(width: 12, height: 12)
            
            Text(noteCategory.name ?? "")
            
            Spacer()
            
            Text("\(noteCategory.thoughtsArray.count)")
                .font(.caption)
                .foregroundColor(.secondary)
            
            Image(systemName: "chevron.right")
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }
}

struct NoteCategoryView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationView {
            NoteCategoryView()
                .environment(\.managedObjectContext,
                              PersistenceController.shared.container.viewContext)
        }
    }
}


### ./YapNotes/Views/NoteCategoryDetailView.swift

import SwiftUI
import CoreData

struct NoteCategoryDetailView: View {
    @ObservedObject var category: NoteCategory
    @Environment(\.managedObjectContext) private var viewContext
    @Environment(\.dismiss) private var dismiss
    @State private var showingEditSheet = false
    
    var body: some View {
        NavigationView {
            List {
                Section {
                    HStack {
                        Circle()
                            .fill(category.color)
                            .frame(width: 16, height: 16)
                        
                        Text(category.name ?? "")
                            .font(.headline)
                        
                        Spacer()
                        
                        if category.isAutoGenerated {
                            Text("Auto-generated")
                                .font(.caption)
                                .foregroundColor(.secondary)
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(Color(.systemGray6))
                                .cornerRadius(8)
                        }
                    }
                }
                
                Section(header: Text("Thoughts")) {
                    if category.thoughtsArray.isEmpty {
                        Text("No thoughts in this category")
                            .foregroundColor(.secondary)
                            .padding(.vertical, 8)
                    } else {
                        ForEach(category.thoughtsArray, id: \.uuid) { thought in
                            ThoughtRow(thought: thought)
                        }
                    }
                }
            }
            .navigationTitle("Category Details")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Done") {
                        dismiss()
                    }
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Menu {
                        Button(action: {
                            showingEditSheet = true
                        }) {
                            Label("Edit", systemImage: "pencil")
                        }
                        
                        Divider()
                        
                        Button(role: .destructive, action: {
                            deleteCategory()
                        }) {
                            Label("Delete", systemImage: "trash")
                        }
                    } label: {
                        Image(systemName: "ellipsis.circle")
                    }
                }
            }
            .sheet(isPresented: $showingEditSheet) {
                NoteCategoryEditView(mode: .edit(category))
            }
        }
    }
    
    private func deleteCategory() {
        viewContext.delete(category)
        try? viewContext.save()
        dismiss()
    }
}

struct ThoughtRow: View {
    let thought: Thought
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(thought.formattedCreationDate)
                .font(.caption)
                .foregroundColor(.secondary)
            
            Text(thought.transcription ?? "")
                .lineLimit(2)
        }
        .padding(.vertical, 4)
    }
}

struct NoteCategoryDetailView_Previews: PreviewProvider {
    static var previews: some View {
        let context = PersistenceController.shared.container.viewContext
        let sampleCategory = NoteCategory.create(
            in: context,
            name: "Sample Category",
            colorHex: "#4A90E2"
        )
        
        return NoteCategoryDetailView(category: sampleCategory)
    }
}

### ./YapNotes/Views/NoteCategoryEditView.swift

import SwiftUI
import CoreData

struct NoteCategoryEditView: View {
    enum Mode {
        case add
        case edit(NoteCategory)
    }
    
    @Environment(\.managedObjectContext) private var viewContext
    @Environment(\.dismiss) private var dismiss
    
    let mode: Mode
    
    @State private var name = ""
    @State private var selectedColorHex = NoteCategory.predefinedColors[0]
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Category Info")) {
                    TextField("Name", text: $name)
                    
                    VStack(alignment: .leading) {
                        Text("Color")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        LazyVGrid(columns: [
                            GridItem(.adaptive(minimum: 44))
                        ], spacing: 8) {
                            ForEach(NoteCategory.predefinedColors, id: \.self) { colorHex in
                                ColorButton(
                                    colorHex: colorHex,
                                    isSelected: selectedColorHex == colorHex
                                ) {
                                    selectedColorHex = colorHex
                                }
                            }
                        }
                    }
                }
            }
            .navigationTitle(title)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(mode == .add ? "Add" : "Save") {
                        saveCategory()
                    }
                    .disabled(name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                }
            }
            .onAppear {
                if case .edit(let category) = mode {
                    name = category.name ?? ""
                    selectedColorHex = category.colorHex ?? NoteCategory.predefinedColors[0]
                }
            }
        }
    }
    
    private var title: String {
        switch mode {
        case .add:
            return "New Category"
        case .edit:
            return "Edit Category"
        }
    }
    
    private func saveCategory() {
        switch mode {
        case .add:
            _ = NoteCategory.create(
                in: viewContext,
                name: name.trimmingCharacters(in: .whitespacesAndNewlines),
                colorHex: selectedColorHex
            )
        case .edit(let category):
            category.name = name.trimmingCharacters(in: .whitespacesAndNewlines)
            category.colorHex = selectedColorHex
        }
        
        try? viewContext.save()
        dismiss()
    }
}

struct ColorButton: View {
    let colorHex: String
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            ZStack {
                Circle()
                    .fill(Color(hex: colorHex))
                    .frame(width: 30, height: 30)
                
                if isSelected {
                    Circle()
                        .strokeBorder(Color.white, lineWidth: 2)
                        .frame(width: 30, height: 30)
                        .background(
                            Circle()
                                .strokeBorder(Color.primary, lineWidth: 1)
                                .frame(width: 34, height: 34)
                        )
                }
            }
            .frame(width: 44, height: 44)
        }
    }
}


### ./YapNotes/Views/CategorySelectionView.swift
// or rename the file to NoteCategorySelectionView.swift

import SwiftUI
import CoreData

struct NoteCategorySelectionView: View {
    @Environment(\.managedObjectContext) private var viewContext
    @Environment(\.dismiss) private var dismiss
    
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \NoteCategory.name, ascending: true)],
        animation: .default
    )
    private var categories: FetchedResults<NoteCategory>
    
    @ObservedObject var thought: Thought
    @State private var showingAddCategory = false
    
    var body: some View {
        NavigationView {
            List {
                Section {
                    ForEach(categories) { category in
                        Button(action: {
                            toggleCategory(category)
                        }) {
                            HStack {
                                Circle()
                                    .fill(category.color)
                                    .frame(width: 12, height: 12)
                                
                                Text(category.name ?? "")
                                
                                Spacer()
                                
                                if isSelected(category) {
                                    Image(systemName: "checkmark")
                                        .foregroundColor(.accentColor)
                                }
                            }
                        }
                        .foregroundColor(.primary)
                    }
                }
                
                Section {
                    Button(action: {
                        showingAddCategory = true
                    }) {
                        Label("Create New Category", systemImage: "plus")
                    }
                }
            }
            .navigationTitle("Select Categories")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
            .sheet(isPresented: $showingAddCategory) {
                NoteCategoryEditView(mode: .add)
            }
        }
    }
    
    private func isSelected(_ category: NoteCategory) -> Bool {
        guard let categories = thought.noteCategories as? Set<NoteCategory> else {
            return false
        }
        
        return categories.contains(category)
    }
    
    private func toggleCategory(_ category: NoteCategory) {
        if isSelected(category) {
            thought.removeFromNoteCategories(category)
        } else {
            thought.addToNoteCategories(category)
        }
        
        try? viewContext.save()
    }
}