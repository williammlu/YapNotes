### ./YapNotes/YapNotesApp.swift

import SwiftUI
import CoreData

@main
struct YapNotesApp: App {
    @StateObject private var persistenceController = PersistenceController.shared
    @StateObject private var modelManager = MLModelManager.shared
    @StateObject private var subscriptionManager = SubscriptionManager.shared
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environment(\.managedObjectContext, persistenceController.container.viewContext)
                .environmentObject(modelManager)
                .environmentObject(subscriptionManager)
                .onAppear {
                    // Check if we need to download default models on first launch
                    Task {
                        await modelManager.ensureDefaultModelsExist()
                    }
                }
        }
    }
}





### ./YapNotes/Models/CoreData/YapNotesDataModel.xcdatamodeld/YapNotesDataModel.xcdatamodel/contents.xml

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<model type="com.apple.IDECoreDataModeler.DataModel" documentVersion="1.0" lastSavedToolsVersion="21513" systemVersion="22E261" minimumToolsVersion="Automatic" sourceLanguage="Swift" userDefinedModelVersionIdentifier="">
    <entity name="Thought" representedClassName="Thought" syncable="YES" codeGenerationType="class">
        <attribute name="audioURL" optional="YES" attributeType="URI"/>
        <attribute name="createdAt" attributeType="Date" usesScalarValueType="NO"/>
        <attribute name="embeddings" optional="YES" attributeType="Binary"/>
        <attribute name="isFavorite" attributeType="Boolean" defaultValueString="NO" usesScalarValueType="YES"/>
        <attribute name="modifiedAt" attributeType="Date" usesScalarValueType="NO"/>
        <attribute name="tags" optional="YES" attributeType="Transformable" valueTransformerName="NSSecureUnarchiveFromDataTransformer" customClassName="[String]"/>
        <attribute name="transcription" attributeType="String"/>
        <attribute name="uuid" attributeType="UUID" usesScalarValueType="NO"/>
        <relationship name="categories" optional="YES" toMany="YES" deletionRule="Nullify" destinationEntity="Category" inverseName="thoughts" inverseEntity="Category"/>
        <relationship name="relatedThoughts" optional="YES" toMany="YES" deletionRule="Nullify" destinationEntity="Thought" inverseName="relatedThoughts" inverseEntity="Thought"/>
    </entity>
    <entity name="Category" representedClassName="Category" syncable="YES" codeGenerationType="class">
        <attribute name="colorHex" attributeType="String" defaultValueString="#4A90E2"/>
        <attribute name="isAutoGenerated" attributeType="Boolean" defaultValueString="NO" usesScalarValueType="YES"/>
        <attribute name="name" attributeType="String"/>
        <attribute name="uuid" attributeType="UUID" usesScalarValueType="NO"/>
        <relationship name="thoughts" optional="YES" toMany="YES" deletionRule="Nullify" destinationEntity="Thought" inverseName="categories" inverseEntity="Thought"/>
    </entity>
</model>



### ./YapNotes/Models/CoreData/PersistenceController.swift

import CoreData

class PersistenceController: ObservableObject {
    static let shared = PersistenceController()
    
    let container: NSPersistentContainer
    
    init(inMemory: Bool = false) {
        container = NSPersistentContainer(name: "YapNotesDataModel")
        
        if inMemory {
            container.persistentStoreDescriptions.first?.url = URL(fileURLWithPath: "/dev/null")
        }
        
        container.loadPersistentStores { description, error in
            if let error = error {
                fatalError("Error loading Core Data stores: \(error.localizedDescription)")
            }
            
            // Merge policy to handle conflicts
            self.container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
            self.container.viewContext.automaticallyMergesChangesFromParent = true
        }
    }
    
    // MARK: - Helper methods for background tasks
    
    func backgroundContext() -> NSManagedObjectContext {
        let context = container.newBackgroundContext()
        context.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        return context
    }
    
    func saveContext(context: NSManagedObjectContext) {
        if context.hasChanges {
            do {
                try context.save()
            } catch {
                let nsError = error as NSError
                print("Error saving Core Data context: \(nsError), \(nsError.userInfo)")
            }
        }
    }
}



### ./YapNotes/Models/ThoughtModel.swift

import Foundation
import CoreData

extension Thought {
    // Extension to provide convenience methods and computed properties
    
    var formattedCreationDate: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        return formatter.string(from: createdAt ?? Date())
    }
    
    var tagsArray: [String] {
        return tags as? [String] ?? []
    }
    
    // Add tags to thought
    func addTags(_ newTags: [String]) {
        var currentTags = tagsArray
        for tag in newTags {
            if !currentTags.contains(tag) {
                currentTags.append(tag)
            }
        }
        tags = currentTags as NSObject
    }
    
    // Remove specific tag
    func removeTag(_ tag: String) {
        var currentTags = tagsArray
        currentTags.removeAll { $0 == tag }
        tags = currentTags as NSObject
    }
    
    // Calculate estimated reading time
    var estimatedReadingTime: Int {
        let words = transcription?.components(separatedBy: .whitespacesAndNewlines).count ?? 0
        return max(1, Int(ceil(Double(words) / 200.0))) // Assuming average reading speed of 200 words per minute
    }
    
    // Create a new thought
    static func create(in context: NSManagedObjectContext, transcription: String, audioURL: URL? = nil) -> Thought {
        let thought = Thought(context: context)
        thought.uuid = UUID()
        thought.transcription = transcription
        thought.audioURL = audioURL
        thought.createdAt = Date()
        thought.modifiedAt = Date()
        thought.isFavorite = false
        thought.tags = [] as NSObject
        
        return thought
    }
}



### ./YapNotes/Models/CategoryModel.swift

import Foundation
import CoreData
import SwiftUI

extension Category {
    // Extension to provide convenience methods and computed properties
    
    var thoughtsArray: [Thought] {
        let set = thoughts as? Set<Thought> ?? []
        return Array(set).sorted { $0.createdAt ?? Date() > $1.createdAt ?? Date() }
    }
    
    var color: Color {
        Color(hex: colorHex ?? "#4A90E2")
    }
    
    // Create a new category
    static func create(in context: NSManagedObjectContext, name: String, colorHex: String, isAutoGenerated: Bool = false) -> Category {
        let category = Category(context: context)
        category.uuid = UUID()
        category.name = name
        category.colorHex = colorHex
        category.isAutoGenerated = isAutoGenerated
        
        return category
    }
    
    // Predefined category colors
    static let predefinedColors = [
        "#4A90E2", // Blue
        "#D64545", // Red
        "#50E3C2", // Teal
        "#F5A623", // Orange
        "#7ED321", // Green
        "#BD10E0", // Purple
        "#9013FE", // Violet
        "#4A4A4A", // Dark Gray
        "#8B572A", // Brown
        "#B8E986"  // Light Green
    ]
    
    // Get a random color for auto-generated categories
    static func randomColor() -> String {
        predefinedColors.randomElement() ?? "#4A90E2"
    }
}

// Helper extension for Color from hex
extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (255, 0, 0, 0)
        }
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue: Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}





### ./YapNotes/Views/ContentView.swift

import SwiftUI

struct ContentView: View {
    @State private var selectedTab = 0
    @State private var isShowingRecording = false
    
    var body: some View {
        ZStack {
            TabView(selection: $selectedTab) {
                NavigationView {
                    ThoughtLibraryView()
                        .navigationTitle("Thoughts")
                }
                .tabItem {
                    Label("Thoughts", systemImage: "list.bullet")
                }
                .tag(0)
                
                NavigationView {
                    CategoryView()
                        .navigationTitle("Categories")
                }
                .tabItem {
                    Label("Categories", systemImage: "tag")
                }
                .tag(1)
                
                NavigationView {
                    SearchView()
                        .navigationTitle("Search")
                }
                .tabItem {
                    Label("Search", systemImage: "magnifyingglass")
                }
                .tag(2)
                
                NavigationView {
                    SettingsView()
                        .navigationTitle("Settings")
                }
                .tabItem {
                    Label("Settings", systemImage: "gear")
                }
                .tag(3)
            }
            
            VStack {
                Spacer()
                
                Button(action: {
                    isShowingRecording = true
                }) {
                    ZStack {
                        Circle()
                            .fill(Color.accentColor)
                            .frame(width: 64, height: 64)
                            .shadow(radius: 4)
                        
                        Image(systemName: "mic.fill")
                            .font(.system(size: 24))
                            .foregroundColor(.white)
                    }
                }
                .padding(.bottom, 16)
                .buttonStyle(ScaleButtonStyle())
            }
        }
        .sheet(isPresented: $isShowingRecording) {
            RecordingView()
        }
    }
}

// Button style that scales on press
struct ScaleButtonStyle: ButtonStyle {
    func makeBody(configuration: Self.Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.9 : 1)
            .animation(.easeOut(duration: 0.1), value: configuration.isPressed)
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
            .environment(\.managedObjectContext, PersistenceController.shared.container.viewContext)
            .environmentObject(MLModelManager.shared)
            .environmentObject(SubscriptionManager.shared)
    }
}



### ./YapNotes/Views/RecordingView.swift

import SwiftUI
import AVFoundation

struct RecordingView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.managedObjectContext) private var viewContext
    @StateObject private var viewModel = RecordingViewModel()
    
    @State private var animateWaveform = false
    
    var body: some View {
        NavigationView {
            VStack {
                Spacer()
                
                // Transcription display
                if viewModel.isTranscribing {
                    VStack(spacing: 16) {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle())
                        
                        Text("Transcribing your thought...")
                            .font(.headline)
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                } else if !viewModel.transcription.isEmpty {
                    ScrollView {
                        Text(viewModel.transcription)
                            .font(.body)
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .padding()
                    }
                    .background(Color(.systemBackground))
                    .cornerRadius(12)
                    .shadow(radius: 2)
                    .padding()
                }
                
                Spacer()
                
                // Audio waveform
                if viewModel.isRecording {
                    HStack(spacing: 4) {
                        ForEach(0..<7, id: \.self) { i in
                            AudioWaveformBar(index: i, isAnimating: animateWaveform)
                        }
                    }
                    .frame(height: 40)
                    .padding(.bottom, 16)
                    .onAppear {
                        withAnimation(Animation.easeInOut(duration: 0.3).repeatForever()) {
                            animateWaveform = true
                        }
                    }
                }
                
                // Recording button and timing
                VStack(spacing: 8) {
                    Button(action: {
                        if viewModel.isRecording {
                            viewModel.stopRecording()
                            animateWaveform = false
                        } else {
                            viewModel.startRecording()
                        }
                    }) {
                        ZStack {
                            Circle()
                                .fill(viewModel.isRecording ? Color.red : Color.accentColor)
                                .frame(width: 80, height: 80)
                                .shadow(radius: 4)
                            
                            if viewModel.isRecording {
                                RoundedRectangle(cornerRadius: 4)
                                    .fill(Color.white)
                                    .frame(width: 24, height: 24)
                            } else {
                                Image(systemName: "mic.fill")
                                    .font(.system(size: 30))
                                    .foregroundColor(.white)
                            }
                        }
                    }
                    .disabled(viewModel.isTranscribing)
                    .buttonStyle(ScaleButtonStyle())
                    
                    if viewModel.isRecording {
                        Text(viewModel.recordingTimeString)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
                .padding(.bottom, 40)
            }
            .navigationTitle("Record Thought")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                    .disabled(viewModel.isTranscribing)
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Save") {
                        if viewModel.transcription.isEmpty {
                            // Nothing to save
                            dismiss()
                        } else {
                            viewModel.saveThought(in: viewContext)
                            dismiss()
                        }
                    }
                    .disabled(viewModel.isRecording || viewModel.isTranscribing || viewModel.transcription.isEmpty)
                }
            }
        }
    }
}

struct AudioWaveformBar: View {
    let index: Int
    let isAnimating: Bool
    
    var body: some View {
        let height = [0.3, 0.5, 0.7, 0.9, 0.7, 0.5, 0.3][index]
        let animatedHeight = isAnimating ? [0.5, 0.7, 0.9, 0.7, 0.9, 0.7, 0.5][index] : height
        
        RoundedRectangle(cornerRadius: 2)
            .fill(Color.accentColor)
            .frame(width: 4, height: 40 * animatedHeight)
            .animation(
                Animation
                    .easeInOut(duration: Double.random(in: 0.2...0.5))
                    .repeatForever(autoreverses: true)
                    .delay(Double.random(in: 0...0.3)),
                value: isAnimating
            )
    }
}

struct RecordingView_Previews: PreviewProvider {
    static var previews: some View {
        RecordingView()
            .environmentObject(MLModelManager.shared)
    }
}



### ./YapNotes/Views/ThoughtLibraryView.swift

import SwiftUI
import CoreData

struct ThoughtLibraryView: View {
    @Environment(\.managedObjectContext) private var viewContext
    
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \Thought.createdAt, ascending: false)],
        animation: .default)
    private var thoughts: FetchedResults<Thought>
    
    @State private var selectedThought: Thought?
    @State private var filterFavorites = false
    
    var body: some View {
        ZStack {
            if thoughts.isEmpty {
                VStack(spacing: 16) {
                    Image(systemName: "mic.fill")
                        .font(.system(size: 50))
                        .foregroundColor(.secondary)
                    
                    Text("No thoughts yet")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    
                    Text("Tap the microphone button to record your first thought")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal)
                }
            } else {
                ScrollView {
                    LazyVStack(spacing: 12) {
                        ForEach(filteredThoughts, id: \.uuid) { thought in
                            ThoughtCard(thought: thought)
                                .onTapGesture {
                                    selectedThought = thought
                                }
                        }
                    }
                    .padding(.horizontal)
                    .padding(.top, 8)
                }
            }
        }
        .navigationBarItems(
            trailing: Menu {
                Button(action: {
                    filterFavorites.toggle()
                }) {
                    Label(
                        filterFavorites ? "Show All" : "Show Favorites",
                        systemImage: filterFavorites ? "list.bullet" : "star.fill"
                    )
                }
                
                Divider()
                
                Menu("Sort By") {
                    Button("Most Recent") {
                        updateSortOrder(keyPath: \Thought.createdAt, ascending: false)
                    }
                    
                    Button("Oldest") {
                        updateSortOrder(keyPath: \Thought.createdAt, ascending: true)
                    }
                }
            } label: {
                Image(systemName: "ellipsis.circle")
            }
        )
        .sheet(item: $selectedThought) { thought in
            ThoughtDetailView(thought: thought)
        }
    }
    
    private var filteredThoughts: [Thought] {
        if filterFavorites {
            return thoughts.filter { $0.isFavorite }
        } else {
            return Array(thoughts)
        }
    }
    
    private func updateSortOrder(keyPath: KeyPath<Thought, Date?>, ascending: Bool) {
        thoughts.nsSortDescriptors = [
            NSSortDescriptor(keyPath: keyPath, ascending: ascending)
        ]
    }
}

struct ThoughtCard: View {
    let thought: Thought
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text(thought.formattedCreationDate)
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                if thought.isFavorite {
                    Image(systemName: "star.fill")
                        .foregroundColor(.yellow)
                }
                
                if thought.audioURL != nil {
                    Image(systemName: "speaker.wave.2.fill")
                        .foregroundColor(.secondary)
                }
            }
            
            Text(thought.transcription ?? "")
                .lineLimit(3)
                .font(.body)
            
            if let tags = thought.tags as? [String], !tags.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack {
                        ForEach(tags, id: \.self) { tag in
                            Text(tag)
                                .font(.caption)
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(Color.accentColor.opacity(0.1))
                                .foregroundColor(.accentColor)
                                .cornerRadius(8)
                        }
                    }
                }
            }
        }
        .padding()
        .background(Color(.systemBackground))
        .cornerRadius(12)
        .shadow(radius: 2)
    }
}

struct ThoughtLibraryView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationView {
            ThoughtLibraryView()
                .environment(\.managedObjectContext, PersistenceController.shared.container.viewContext)
        }
    }
}



### ./YapNotes/Views/ThoughtDetailView.swift

import SwiftUI
import AVFoundation

struct ThoughtDetailView: View {
    @Environment(\.managedObjectContext) private var viewContext
    @Environment(\.dismiss) private var dismiss
    
    @ObservedObject var thought: Thought
    @StateObject private var audioPlayer = AudioPlayerController()
    @State private var isEditing = false
    @State private var editedText = ""
    @State private var showingCategorySheet = false
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 16) {
                    // Creation date and audio controls
                    HStack {
                        Text(thought.formattedCreationDate)
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                        
                        Spacer()
                        
                        if let audioURL = thought.audioURL {
                            HStack {
                                Button(action: {
                                    if audioPlayer.isPlaying {
                                        audioPlayer.pauseAudio()
                                    } else {
                                        audioPlayer.playAudio(from: audioURL)
                                    }
                                }) {
                                    Image(systemName: audioPlayer.isPlaying ? "pause.circle.fill" : "play.circle.fill")
                                        .font(.system(size: 28))
                                }
                                
                                if audioPlayer.isPlaying {
                                    Text(audioPlayer.formattedProgress)
                                        .font(.caption)
                                        .monospacedDigit()
                                        .foregroundColor(.secondary)
                                }
                            }
                        }
                    }
                    .padding(.horizontal)
                    
                    // Text content
                    if isEditing {
                        TextEditor(text: $editedText)
                            .font(.body)
                            .padding(8)
                            .background(Color(.systemGray6))
                            .cornerRadius(8)
                            .frame(minHeight: 200)
                            .padding(.horizontal)
                    } else {
                        Text(thought.transcription ?? "")
                            .font(.body)
                            .padding(.horizontal)
                    }
                    
                    // Categories
                    VStack(alignment: .leading, spacing: 8) {
                        HStack {
                            Text("Categories")
                                .font(.headline)
                            
                            Spacer()
                            
                            Button(action: {
                                showingCategorySheet = true
                            }) {
                                Image(systemName: "plus.circle")
                                    .font(.system(size: 18))
                            }
                        }
                        
                        if let categories = thought.categories as? Set<Category>, !categories.isEmpty {
                            ScrollView(.horizontal, showsIndicators: false) {
                                HStack {
                                    ForEach(Array(categories), id: \.uuid) { category in
                                        CategoryPill(category: category) {
                                            removeFromCategory(category)
                                        }
                                    }
                                }
                            }
                        } else {
                            Text("No categories assigned")
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                        }
                    }
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
                    .padding(.horizontal)
                    
                    // Tags
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Tags")
                            .font(.headline)
                        
                        if let tags = thought.tags as? [String], !tags.isEmpty {
                            TagCloud(tags: tags) { tag in
                                thought.removeTag(tag)
                                try? viewContext.save()
                            }
                        } else {
                            Text("No tags")
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                        }
                    }
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
                    .padding(.horizontal)
                    
                    // Related thoughts
                    if let relatedThoughts = thought.relatedThoughts as? Set<Thought>, !relatedThoughts.isEmpty {
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Related Thoughts")
                                .font(.headline)
                                .padding(.horizontal)
                            
                            ScrollView(.horizontal, showsIndicators: false) {
                                HStack(spacing: 12) {
                                    ForEach(Array(relatedThoughts), id: \.uuid) { relatedThought in
                                        RelatedThoughtCard(thought: relatedThought)
                                    }
                                }
                                .padding(.horizontal)
                            }
                        }
                    }
                }
                .padding(.vertical)
            }
            .navigationTitle(isEditing ? "Edit Thought" : "Thought")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button(action: {
                        dismiss()
                    }) {
                        Text("Done")
                    }
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Menu {
                        if isEditing {
                            Button("Save") {
                                saveEdit()
                            }
                            
                            Button("Cancel", role: .cancel) {
                                isEditing = false
                            }
                        } else {
                            Button(action: {
                                toggleFavorite()
                            }) {
                                Label(
                                    thought.isFavorite ? "Remove from Favorites" : "Add to Favorites",
                                    systemImage: thought.isFavorite ? "star.slash" : "star"
                                )
                            }
                            
                            Button(action: {
                                editedText = thought.transcription ?? ""
                                isEditing = true
                            }) {
                                Label("Edit", systemImage: "pencil")
                            }
                            
                            Button(action: {
                                shareThought()
                            }) {
                                Label("Share", systemImage: "square.and.arrow.up")
                            }
                            
                            Divider()
                            
                            Button(role: .destructive, action: {
                                deleteThought()
                            }) {
                                Label("Delete", systemImage: "trash")
                            }
                        }
                    } label: {
                        if isEditing {
                            Text("Done")
                        } else {
                            Image(systemName: "ellipsis.circle")
                        }
                    }
                }
            }
            .sheet(isPresented: $showingCategorySheet) {
                CategorySelectionView(thought: thought)
            }
        }
    }
    
    private func toggleFavorite() {
        thought.isFavorite.toggle()
        try? viewContext.save()
    }
    
    private func saveEdit() {
        thought.transcription = editedText
        thought.modifiedAt = Date()
        try? viewContext.save()
        isEditing = false
    }
    
    private func removeFromCategory(_ category: Category) {
        thought.removeFromCategories(category)
        try? viewContext.save()
    }
    
    private func deleteThought() {
        viewContext.delete(thought)
        try? viewContext.save()
        dismiss()
    }
    
    private func shareThought() {
        let text = thought.transcription ?? ""
        let activityViewController = UIActivityViewController(
            activityItems: [text],
            applicationActivities: nil
        )
        
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let rootViewController = windowScene.windows.first?.rootViewController {
            rootViewController.present(activityViewController, animated: true)
        }
    }
}

struct CategoryPill: View {
    let category: Category
    let onRemove: () -> Void
    
    var body: some View {
        HStack(spacing: 4) {
            Circle()
                .fill(category.color)
                .frame(width: 8, height: 8)
            
            Text(category.name ?? "")
                .font(.subheadline)
            
            Button(action: onRemove) {
                Image(systemName: "xmark.circle.fill")
                    .font(.system(size: 12))
                    .foregroundColor(.secondary)
            }
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 4)
        .background(category.color.opacity(0.1))
        .cornerRadius(12)
    }
}

struct TagCloud: View {
    let tags: [String]
    let onRemove: (String) -> Void
    
    var body: some View {
        FlowLayout(spacing: 8) {
            ForEach(tags, id: \.self) { tag in
                HStack(spacing: 4) {
                    Text(tag)
                        .font(.caption)
                    
                    Button(action: {
                        onRemove(tag)
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.system(size: 10))
                            .foregroundColor(.secondary)
                    }
                }
                .padding(.horizontal, 8)
                .padding(.vertical, 4)
                .background(Color.accentColor.opacity(0.1))
                .foregroundColor(.accentColor)
                .cornerRadius(8)
            }
        }
    }
}

struct RelatedThoughtCard: View {
    let thought: Thought
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(thought.formattedCreationDate)
                .font(.caption)
                .foregroundColor(.secondary)
            
            Text(thought.transcription ?? "")
                .font(.caption)
                .lineLimit(3)
                .frame(width: 160)
        }
        .padding()
        .background(Color(.systemGray6))
        .cornerRadius(8)
    }
}

struct FlowLayout: Layout {
    let spacing: CGFloat
    
    func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout Void) -> CGSize {
        let width = proposal.width ?? 0
        var height: CGFloat = 0
        var x: CGFloat = 0
        var y: CGFloat = 0
        var maxHeight: CGFloat = 0
        
        for view in subviews {
            let viewSize = view.sizeThatFits(.unspecified)
            
            if x + viewSize.width > width {
                x = 0
                y += maxHeight + spacing
                maxHeight = 0
            }
            
            maxHeight = max(maxHeight, viewSize.height)
            x += viewSize.width + spacing
            
            height = max(height, y + viewSize.height)
        }
        
        return CGSize(width: width, height: height)
    }
    
    func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout Void) {
        var x: CGFloat = bounds.minX
        var y: CGFloat = bounds.minY
        var maxHeight: CGFloat = 0
        
        for view in subviews {
            let viewSize = view.sizeThatFits(.unspecified)
            
            if x + viewSize.width > bounds.maxX {
                x = bounds.minX
                y += maxHeight + spacing
                maxHeight = 0
            }
            
            view.place(at: CGPoint(x: x, y: y), proposal: ProposedViewSize(width: viewSize.width, height: viewSize.height))
            
            maxHeight = max(maxHeight, viewSize.height)
            x += viewSize.width + spacing
        }
    }
}

// Controller for audio playback
class AudioPlayerController: ObservableObject {
    private var audioPlayer: AVAudioPlayer?
    private var progressTimer: Timer?
    
    @Published var isPlaying = false
    @Published var progress: TimeInterval = 0
    
    var formattedProgress: String {
        let formatter = DateComponentsFormatter()
        formatter.allowedUnits = [.minute, .second]
        formatter.zeroFormattingBehavior = .pad
        return formatter.string(from: progress) ?? "0:00"
    }
    
    func playAudio(from url: URL) {
        do {
            audioPlayer = try AVAudioPlayer(contentsOf: url)
            audioPlayer?.prepareToPlay()
            audioPlayer?.play()
            isPlaying = true
            
            startProgressTimer()
        } catch {
            print("Error playing audio: \(error.localizedDescription)")
        }
    }
    
    func pauseAudio() {
        audioPlayer?.pause()
        isPlaying = false
        stopProgressTimer()
    }
    
    private func startProgressTimer() {
        progressTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { [weak self] _ in
            guard let self = self, let player = self.audioPlayer else { return }
            self.progress = player.currentTime
            
            if !player.isPlaying {
                self.isPlaying = false
                self.stopProgressTimer()
            }
        }
    }
    
    private func stopProgressTimer() {
        progressTimer?.invalidate()
        progressTimer = nil
    }
}

struct ThoughtDetailView_Previews: PreviewProvider {
    static var previews: some View {
        let context = PersistenceController.shared.container.viewContext
        let sampleThought = Thought.create(in: context, transcription: "This is a sample thought for preview.")
        
        return ThoughtDetailView(thought: sampleThought)
    }
}



### ./YapNotes/Views/CategoryView.swift

import SwiftUI
import CoreData

struct CategoryView: View {
    @Environment(\.managedObjectContext) private var viewContext
    
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \Category.name, ascending: true)],
        animation: .default)
    private var categories: FetchedResults<Category>
    
    @State private var showingAddCategory = false
    @State private var selectedCategory: Category?
    
    var body: some View {
        ZStack {
            if categories.isEmpty {
                VStack(spacing: 16) {
                    Image(systemName: "tag.fill")
                        .font(.system(size: 50))
                        .foregroundColor(.secondary)
                    
                    Text("No categories yet")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    
                    Text("Categories help you organize your thoughts")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal)
                    
                    Button(action: {
                        showingAddCategory = true
                    }) {
                        Label("Create Category", systemImage: "plus")
                            .padding(.horizontal, 16)
                            .padding(.vertical, 8)
                            .background(Color.accentColor)
                            .foregroundColor(.white)
                            .cornerRadius(8)
                    }
                    .padding(.top, 8)
                }
            } else {
                List {
                    ForEach(categories) { category in
                        CategoryListItem(category: category)
                            .onTapGesture {
                                selectedCategory = category
                            }
                    }
                    .onDelete(perform: deleteCategories)
                }
            }
        }
        .navigationBarItems(trailing: Button(action: {
            showingAddCategory = true
        }) {
            Image(systemName: "plus")
        })
        .sheet(isPresented: $showingAddCategory) {
            CategoryEditView(mode: .add)
        }
        .sheet(item: $selectedCategory) { category in
            CategoryDetailView(category: category)
        }
    }
    
    private func deleteCategories(offsets: IndexSet) {
        withAnimation {
            offsets.map { categories[$0] }.forEach(viewContext.delete)
            
            do {
                try viewContext.save()
            } catch {
                print("Error deleting categories: \(error.localizedDescription)")
            }
        }
    }
}

struct CategoryListItem: View {
    @ObservedObject var category: Category
    
    var body: some View {
        HStack {
            Circle()
                .fill(category.color)
                .frame(width: 12, height: 12)
            
            Text(category.name ?? "")
            
            Spacer()
            
            Text("\(category.thoughtsArray.count)")
                .font(.caption)
                .foregroundColor(.secondary)
            
            Image(systemName: "chevron.right")
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }
}

struct CategoryEditView: View {
    enum Mode {
        case add
        case edit(Category)
    }
    
    @Environment(\.managedObjectContext) private var viewContext
    @Environment(\.dismiss) private var dismiss
    
    let mode: Mode
    
    @State private var name = ""
    @State private var selectedColorHex = Category.predefinedColors[0]
    
    var body: some View {
        NavigationView {
            Form {
                Section(header: Text("Category Info")) {
                    TextField("Name", text: $name)
                    
                    VStack(alignment: .leading) {
                        Text("Color")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        LazyVGrid(columns: [
                            GridItem(.adaptive(minimum: 44))
                        ], spacing: 8) {
                            ForEach(Category.predefinedColors, id: \.self) { colorHex in
                                ColorButton(
                                    colorHex: colorHex,
                                    isSelected: selectedColorHex == colorHex,
                                    action: { selectedColorHex = colorHex }
                                )
                            }
                        }
                    }
                }
            }
            .navigationTitle(title)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(mode == .add ? "Add" : "Save") {
                        saveCategory()
                    }
                    .disabled(name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                }
            }
            .onAppear {
                if case .edit(let category) = mode {
                    name = category.name ?? ""
                    selectedColorHex = category.colorHex ?? Category.predefinedColors[0]
                }
            }
        }
    }
    
    private var title: String {
        switch mode {
        case .add:
            return "New Category"
        case .edit:
            return "Edit Category"
        }
    }
    
    private func saveCategory() {
        switch mode {
        case .add:
            _ = Category.create(
                in: viewContext,
                name: name.trimmingCharacters(in: .whitespacesAndNewlines),
                colorHex: selectedColorHex
            )
        case .edit(let category):
            category.name = name.trimmingCharacters(in: .whitespacesAndNewlines)
            category.colorHex = selectedColorHex
        }
        
        try? viewContext.save()
        dismiss()
    }
}

struct ColorButton: View {
    let colorHex: String
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            ZStack {
                Circle()
                    .fill(Color(hex: colorHex))
                    .frame(width: 30, height: 30)
                
                if isSelected {
                    Circle()
                        .strokeBorder(Color.white, lineWidth: 2)
                        .frame(width: 30, height: 30)
                        .background(
                            Circle()
                                .strokeBorder(Color.primary, lineWidth: 1)
                                .frame(width: 34, height: 34)
                        )
                }
            }
            .frame(width: 44, height: 44)
        }
    }
}

struct CategoryDetailView: View {
    @ObservedObject var category: Category
    @Environment(\.managedObjectContext) private var viewContext
    @Environment(\.dismiss) private var dismiss
    @State private var showingEditSheet = false
    
    var body: some View {
        NavigationView {
            List {
                Section {
                    HStack {
                        Circle()
                            .fill(category.color)
                            .frame(width: 16, height: 16)
                        
                        Text(category.name ?? "")
                            .font(.headline)
                        
                        Spacer()
                        
                        if category.isAutoGenerated {
                            Text("Auto-generated")
                                .font(.caption)
                                .foregroundColor(.secondary)
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(Color(.systemGray6))
                                .cornerRadius(8)
                        }
                    }
                }
                
                Section(header: Text("Thoughts")) {
                    if category.thoughtsArray.isEmpty {
                        Text("No thoughts in this category")
                            .foregroundColor(.secondary)
                            .padding(.vertical, 8)
                    } else {
                        ForEach(category.thoughtsArray, id: \.uuid) { thought in
                            ThoughtRow(thought: thought)
                        }
                    }
                }
            }
            .navigationTitle("Category Details")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Done") {
                        dismiss()
                    }
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Menu {
                        Button(action: {
                            showingEditSheet = true
                        }) {
                            Label("Edit", systemImage: "pencil")
                        }
                        
                        Divider()
                        
                        Button(role: .destructive, action: {
                            deleteCategory()
                        }) {
                            Label("Delete", systemImage: "trash")
                        }
                    } label: {
                        Image(systemName: "ellipsis.circle")
                    }
                }
            }
            .sheet(isPresented: $showingEditSheet) {
                CategoryEditView(mode: .edit(category))
            }
        }
    }
    
    private func deleteCategory() {
        viewContext.delete(category)
        try? viewContext.save()
        dismiss()
    }
}

struct ThoughtRow: View {
    let thought: Thought
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(thought.formattedCreationDate)
                .font(.caption)
                .foregroundColor(.secondary)
            
            Text(thought.transcription ?? "")
                .lineLimit(2)
        }
        .padding(.vertical, 4)
    }
}

struct CategorySelectionView: View {
    @Environment(\.managedObjectContext) private var viewContext
    @Environment(\.dismiss) private var dismiss
    
    @FetchRequest(
        sortDescriptors: [NSSortDescriptor(keyPath: \Category.name, ascending: true)],
        animation: .default)
    private var categories: FetchedResults<Category>
    
    @ObservedObject var thought: Thought
    @State private var showingAddCategory = false
    
    var body: some View {
        NavigationView {
            List {
                Section {
                    ForEach(categories) { category in
                        Button(action: {
                            toggleCategory(category)
                        }) {
                            HStack {
                                Circle()
                                    .fill(category.color)
                                    .frame(width: 12, height: 12)
                                
                                Text(category.name ?? "")
                                
                                Spacer()
                                
                                if isSelected(category) {
                                    Image(systemName: "checkmark")
                                        .foregroundColor(.accentColor)
                                }
                            }
                        }
                        .foregroundColor(.primary)
                    }
                }
                
                Section {
                    Button(action: {
                        showingAddCategory = true
                    }) {
                        Label("Create New Category", systemImage: "plus")
                    }
                }
            }
            .navigationTitle("Select Categories")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
            .sheet(isPresented: $showingAddCategory) {
                CategoryEditView(mode: .add)
            }
        }
    }
    
    private func isSelected(_ category: Category) -> Bool {
        guard let thoughtCategories = thought.categories as? Set<Category> else {
            return false
        }
        
        return thoughtCategories.contains(category)
    }
    
    private func toggleCategory(_ category: Category) {
        if isSelected(category) {
            thought.removeFromCategories(category)
        } else {
            thought.addToCategories(category)
        }
        
        try? viewContext.save()
    }
}

struct CategoryView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationView {
            CategoryView()
                .environment(\.managedObjectContext, PersistenceController.shared.container.viewContext)
        }
    }
}



### ./YapNotes/Views/SearchView.swift

import SwiftUI
import CoreData

struct SearchView: View {
    @Environment(\.managedObjectContext) private var viewContext
    @State private var searchText = ""
    @State private var selectedThought: Thought?
    
    @State private var searchResults: [Thought] = []
    @State private var isSearching = false
    
    var body: some View {
        VStack {
            SearchBar(text: $searchText, onCommit: performSearch)
                .padding(.horizontal)
            
            if isSearching {
                ProgressView()
                    .padding()
            } else if searchText.isEmpty {
                SearchPlaceholderView()
            } else if searchResults.isEmpty {
                VStack(spacing: 16) {
                    Image(systemName: "magnifyingglass")
                        .font(.system(size: 40))
                        .foregroundColor(.secondary)
                    
                    Text("No results found")
                        .font(.headline)
                    
                    Text("Try a different search term")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                .padding()
            } else {
                List {
                    ForEach(searchResults, id: \.uuid) { thought in
                        ThoughtRow(thought: thought)
                            .onTapGesture {
                                selectedThought = thought
                            }
                    }
                }
            }
        }
        .sheet(item: $selectedThought) { thought in
            ThoughtDetailView(thought: thought)
        }
    }
    
    private func performSearch() {
        guard !searchText.isEmpty else {
            searchResults = []
            return
        }
        
        isSearching = true
        
        // Create a background context for search
        let searchContext = viewContext.parent!.newBackgroundContext()
        
        Task {
            let results = await withCheckedContinuation { continuation in
                searchContext.perform {
                    let request = NSFetchRequest<Thought>(entityName: "Thought")
                    request.predicate = NSPredicate(
                        format: "transcription CONTAINS[cd] %@",
                        searchText
                    )
                    request.sortDescriptors = [
                        NSSortDescriptor(keyPath: \Thought.createdAt, ascending: false)
                    ]
                    
                    do {
                        let thoughts = try searchContext.fetch(request)
                        // Convert to object IDs to safely pass between contexts
                        let thoughtIDs = thoughts.map { $0.objectID }
                        continuation.resume(returning: thoughtIDs)
                    } catch {
                        print("Error performing search: \(error.localizedDescription)")
                        continuation.resume(returning: [])
                    }
                }
            }
            
            // Convert object IDs back to objects in the main context
            searchResults = results.compactMap { viewContext.object(with: $0) as? Thought }
            isSearching = false
        }
    }
}

struct SearchBar: View {
    @Binding var text: String
    var onCommit: () -> Void
    
    @FocusState private var isSearchFocused: Bool
    
    var body: some View {
        HStack {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.secondary)
            
            TextField("Search thoughts", text: $text)
                .focused($isSearchFocused)
                .onSubmit(onCommit)
                .submitLabel(.search)
            
            if !text.isEmpty {
                Button(action: {
                    text = ""
                }) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding(10)
        .background(Color(.systemGray6))
        .cornerRadius(10)
        .onAppear {
            isSearchFocused = true
        }
    }
}

struct SearchPlaceholderView: View {
    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: "magnifyingglass")
                .font(.system(size: 50))
                .foregroundColor(.secondary)
            
            Text("Search for Thoughts")
                .font(.headline)
            
            VStack(alignment: .leading, spacing: 12) {
                Text("Search by:")
                    .font(.subheadline)
                    .fontWeight(.medium)
                
                HStack {
                    Image(systemName: "text.magnifyingglass")
                        .frame(width: 24)
                    Text("Keywords in your thought")
                }
                
                HStack {
                    Image(systemName: "tag")
                        .frame(width: 24)
                    Text("Tags and categories")
                }
            }
            .padding()
            .background(Color(.systemGray6))
            .cornerRadius(12)
        }
        .padding()
    }
}

struct SearchView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationView {
            SearchView()
                .environment(\.managedObjectContext, PersistenceController.shared.container.viewContext)
        }
    }
}



### ./YapNotes/Views/SettingsView.swift

import SwiftUI

struct SettingsView: View {
    @EnvironmentObject private var modelManager: MLModelManager
    @EnvironmentObject private var subscriptionManager: SubscriptionManager
    @State private var showingSubscriptionSheet = false
    
    var body: some View {
        Form {
            Section(header: Text("Subscription")) {
                if subscriptionManager.isPremium {
                    HStack {
                        Label("Premium Subscription", systemImage: "star.fill")
                            .foregroundColor(.yellow)
                        Spacer()
                        Text("Active")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                } else {
                    Button(action: {
                        showingSubscriptionSheet = true
                    }) {
                        HStack {
                            Label("Upgrade to Premium", systemImage: "star")
                            Spacer()
                            Image(systemName: "chevron.right")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                }
            }
            
            Section(header: Text("Speech Recognition Models")) {
                ForEach(ModelType.allCases, id: \.self) { modelType in
                    HStack {
                        VStack(alignment: .leading) {
                            Text(modelType.displayName)
                            Text(modelType.description)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        
                        Spacer()
                        
                        ModelStatusView(modelType: modelType)
                    }
                    .padding(.vertical, 4)
                }
            }
            
            Section(header: Text("Storage")) {
                NavigationLink(destination: StorageManagementView()) {
                    HStack {
                        Label("Manage Storage", systemImage: "folder")
                        Spacer()
                        Text(modelManager.totalStorageUsedFormatted)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            }
            
            Section(header: Text("About")) {
                HStack {
                    Text("Version")
                    Spacer()
                    Text(Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as? String ?? "1.0.0")
                        .foregroundColor(.secondary)
                }
                
                Link(destination: URL(string: "https://yapnotes.app/privacy")!) {
                    HStack {
                        Text("Privacy Policy")
                        Spacer()
                        Image(systemName: "arrow.up.right.square")
                            .font(.caption)
                    }
                }
                
                Link(destination: URL(string: "https://yapnotes.app/terms")!) {
                    HStack {
                        Text("Terms of Service")
                        Spacer()
                        Image(systemName: "arrow.up.right.square")
                            .font(.caption)
                    }
                }
            }
        }
        .sheet(isPresented: $showingSubscriptionSheet) {
            SubscriptionView()
        }
    }
}

struct ModelStatusView: View {
    @EnvironmentObject private var modelManager: MLModelManager
    let modelType: ModelType
    
    var body: some View {
        Group {
            if modelManager.isModelDownloaded(modelType) {
                Text("Downloaded")
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(Color.green.opacity(0.2))
                    .foregroundColor(.green)
                    .cornerRadius(4)
            } else if modelManager.isModelDownloading(modelType) {
                HStack(spacing: 4) {
                    ProgressView()
                        .scaleEffect(0.7)
                    Text("\(Int(modelManager.downloadProgress(for: modelType) * 100))%")
                        .font(.caption)
                }
            } else if !modelType.requiresPremium || (modelType.requiresPremium && modelManager.subscriptionManager.isPremium) {
                Button(action: {
                    Task {
                        try await modelManager.downloadModel(modelType)
                    }
                }) {
                    Text("Download")
                        .font(.caption)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(Color.accentColor.opacity(0.2))
                        .foregroundColor(.accentColor)
                        .cornerRadius(4)
                }
            } else {
                Image(systemName: "lock.fill")
                    .foregroundColor(.secondary)
            }
        }
    }
}

struct StorageManagementView: View {
    @EnvironmentObject private var modelManager: MLModelManager
    @State private var isConfirmingDelete = false
    @State private var modelToDelete: ModelType?
    
    var body: some View {
        List {
            Section(header: Text("Models")) {
                ForEach(modelManager.downloadedModels, id: \.self) { modelType in
                    HStack {
                        VStack(alignment: .leading) {
                            Text(modelType.displayName)
                            Text(modelType.sizeString)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        
                        Spacer()
                        
                        if modelType != .whisperTiny {
                            Button(action: {
                                modelToDelete = modelType
                                isConfirmingDelete = true
                            }) {
                                Text("Remove")
                                    .font(.caption)
                                    .foregroundColor(.red)
                            }
                        } else {
                            Text("Required")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                }
            }
            
            Section(header: Text("Audio Files")) {
                HStack {
                    VStack(alignment: .leading) {
                        Text("Audio Recordings")
                        Text("\(modelManager.audioFileCount) files, \(modelManager.audioStorageUsedFormatted)")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    
                    Spacer()
                    
                    Button(action: {
                        // TODO: Implement clearing all audio files
                    }) {
                        Text("Clear All")
                            .font(.caption)
                            .foregroundColor(.red)
                    }
                }
            }
        }
        .alert("Remove Model", isPresented: $isConfirmingDelete) {
            Button("Cancel", role: .cancel) {
                modelToDelete = nil
            }
            
            Button("Remove", role: .destructive) {
                if let model = modelToDelete {
                    Task {
                        await modelManager.deleteModel(model)
                    }
                }
                modelToDelete = nil
            }
        } message: {
            if let model = modelToDelete {
                Text("Are you sure you want to remove the \(model.displayName) model? You can download it again later if needed.")
            }
        }
        .navigationTitle("Storage")
    }
}

struct SubscriptionView: View {
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject private var subscriptionManager: SubscriptionManager
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 24) {
                    // Header
                    VStack(spacing: 8) {
                        Image(systemName: "star.fill")
                            .font(.system(size: 60))
                            .foregroundColor(.yellow)
                        
                        Text("YapNotes Premium")
                            .font(.title)
                            .fontWeight(.bold)
                        
                        Text("Take your thoughts to the next level")
                            .font(.headline)
                            .foregroundColor(.secondary)
                    }
                    .padding(.top, 40)
                    .padding(.bottom, 20)
                    
                    // Features
                    VStack(alignment: .leading, spacing: 16) {
                        FeatureRow(icon: "infinity", title: "Unlimited Thoughts", description: "Capture as many thoughts as you want")
                        
                        FeatureRow(icon: "waveform", title: "Advanced Transcription", description: "Access to the most accurate speech recognition models")
                        
                        FeatureRow(icon: "brain", title: "Smart Organization", description: "Better categorization and thought relationships")
                        
                        FeatureRow(icon: "square.and.arrow.up", title: "Export Options", description: "Export your thoughts in multiple formats")
                    }
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
                    .padding(.horizontal)
                    
                    // Subscription options
                    VStack(spacing: 16) {
                        Button(action: {
                            Task {
                                await subscriptionManager.purchaseSubscription(.monthly)
                            }
                        }) {
                            HStack {
                                Text("Monthly")
                                    .font(.headline)
                                Spacer()
                                Text("$7.99 / month")
                            }
                            .padding()
                            .background(Color.accentColor)
                            .foregroundColor(.white)
                            .cornerRadius(12)
                        }
                        
                        Button(action: {
                            Task {
                                await subscriptionManager.purchaseSubscription(.yearly)
                            }
                        }) {
                            VStack(alignment: .leading, spacing: 4) {
                                HStack {
                                    Text("Yearly")
                                        .font(.headline)
                                    
                                    Text("SAVE 16%")
                                        .font(.caption)
                                        .padding(.horizontal, 8)
                                        .padding(.vertical, 4)
                                        .background(Color.yellow)
                                        .foregroundColor(.black)
                                        .cornerRadius(4)
                                    
                                    Spacer()
                                    
                                    Text("$79.99 / year")
                                }
                                
                                Text("$6.67 / month, billed annually")
                                    .font(.caption)
                                    .foregroundColor(Color(.systemGray))
                            }
                            .padding()
                            .background(Color.accentColor)
                            .foregroundColor(.white)
                            .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal)
                    
                    // Terms and privacy
                    Text("Subscriptions will automatically renew unless canceled within 24-hours before the end of the current period. You can cancel anytime with your iTunes account settings.")
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal, 24)
                        .padding(.top)
                    
                    HStack(spacing: 20) {
                        Button(action: {
                            // Open terms URL
                        }) {
                            Text("Terms of Use")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        
                        Button(action: {
                            // Open privacy URL
                        }) {
                            Text("Privacy Policy")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                    .padding(.bottom, 40)
                }
            }
            .navigationBarItems(trailing: Button("Done") {
                dismiss()
            })
        }
    }
}

struct FeatureRow: View {
    let icon: String
    let title: String
    let description: String
    
    var body: some View {
        HStack(spacing: 16) {
            Image(systemName: icon)
                .font(.system(size: 24))
                .frame(width: 32, height: 32)
                .foregroundColor(.accentColor)
            
            VStack(alignment: .leading, spacing: 4) {
                Text(title)
                    .font(.headline)
                
                Text(description)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
        }
    }
}

struct SettingsView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationView {
            SettingsView()
                .environmentObject(MLModelManager.shared)
                .environmentObject(SubscriptionManager.shared)
        }
    }
}





### ./YapNotes/ViewModels/RecordingViewModel.swift

import SwiftUI
import AVFoundation
import Combine

class RecordingViewModel: NSObject, ObservableObject, AVAudioRecorderDelegate {
    
    @Published var isRecording = false
    @Published var isTranscribing = false
    @Published var transcription = ""
    @Published var recordingTime: TimeInterval = 0
    
    private var audioRecorder: AVAudioRecorder?
    private var recordingSession: AVAudioSession?
    private var audioURL: URL?
    private var timer: Timer?
    
    private let transcriptionService = TranscriptionService.shared
    private let organizationService = OrganizationService.shared
    
    var recordingTimeString: String {
        let minutes = Int(recordingTime) / 60
        let seconds = Int(recordingTime) % 60
        return String(format: "%02d:%02d", minutes, seconds)
    }
    
    override init() {
        super.init()
        setupAudioSession()
    }
    
    func startRecording() {
        let audioFilename = getDocumentsDirectory().appendingPathComponent("\(UUID().uuidString).m4a")
        
        let settings = [
            AVFormatIDKey: Int(kAudioFormatMPEG4AAC),
            AVSampleRateKey: 16000,
            AVNumberOfChannelsKey: 1,
            AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
        ]
        
        do {
            audioRecorder = try AVAudioRecorder(url: audioFilename, settings: settings)
            audioRecorder?.delegate = self
            audioRecorder?.record()
            
            audioURL = audioFilename
            isRecording = true
            recordingTime = 0
            
            // Start timer to update recording time
            timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { [weak self] _ in
                guard let self = self else { return }
                self.recordingTime += 0.1
            }
        } catch {
            print("Failed to start recording: \(error.localizedDescription)")
        }
    }
    
    func stopRecording() {
        audioRecorder?.stop()
        timer?.invalidate()
        timer = nil
        isRecording = false
        
        guard let url = audioURL else { return }
        
        isTranscribing = true
        
        Task {
            do {
                // First try Apple's speech recognition for quick feedback
                let quickResult = try await transcriptionService.transcribeWithAppleSpeech(audioURL: url)
                
                DispatchQueue.main.async {
                    self.transcription = quickResult
                }
                
                // Then use WhisperCPP for more accurate results
                let finalResult = try await transcriptionService.transcribeWithWhisper(audioURL: url)
                
                DispatchQueue.main.async {
                    self.transcription = finalResult
                    self.isTranscribing = false
                }
            } catch {
                print("Transcription error: \(error.localizedDescription)")
                
                DispatchQueue.main.async {
                    self.isTranscribing = false
                }
            }
        }
    }
    
    func saveThought(in context: NSManagedObjectContext) {
        let thought = Thought.create(
            in: context,
            transcription: transcription,
            audioURL: audioURL
        )
        
        do {
            try context.save()
            
            // Process the thought in the background for categorization
            Task {
                try await organizationService.processNewThought(thought)
                
                // Save again after processing
                try await context.perform {
                    try context.save()
                }
            }
        } catch {
            print("Error saving thought: \(error.localizedDescription)")
        }
    }
    
    private func setupAudioSession() {
        recordingSession = AVAudioSession.sharedInstance()
        
        do {
            try recordingSession?.setCategory(.playAndRecord, mode: .default)
            try recordingSession?.setActive(true)
            
            recordingSession?.requestRecordPermission() { [weak self] allowed in
                DispatchQueue.main.async {
                    if !allowed {
                        print("Microphone access denied")
                    }
                }
            }
        } catch {
            print("Failed to set up recording session: \(error.localizedDescription)")
        }
    }
    
    private func getDocumentsDirectory() -> URL {
        let paths = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)
        let documentsDirectory = paths[0].appendingPathComponent("Audio", isDirectory: true)
        
        // Create Audio directory if it doesn't exist
        if !FileManager.default.fileExists(atPath: documentsDirectory.path) {
            try? FileManager.default.createDirectory(at: documentsDirectory, withIntermediateDirectories: true)
        }
        
        return documentsDirectory
    }
    
    // MARK: - AVAudioRecorderDelegate
    
    func audioRecorderDidFinishRecording(_ recorder: AVAudioRecorder, successfully flag: Bool) {
        if !flag {
            print("Recording finished unsuccessfully")
        }
    }
}



### ./YapNotes/ViewModels/OrganizationViewModel.swift

import SwiftUI
import CoreData
import Combine

class OrganizationViewModel: ObservableObject {
    @Published var suggestedCategories: [CategorySuggestion] = []
    @Published var isProcessing = false
    @Published var relatedThoughts: [Thought] = []
    
    private let organizationService = OrganizationService.shared
    private var cancellables = Set<AnyCancellable>()
    
    func processThought(_ thought: Thought, in context: NSManagedObjectContext) {
        isProcessing = true
        
        Task {
            do {
                // Process the thought to get suggestions
                let (categories, related) = try await organizationService.processThought(thought, in: context)
                
                DispatchQueue.main.async {
                    self.suggestedCategories = categories
                    self.relatedThoughts = related
                    self.isProcessing = false
                }
            } catch {
                print("Error processing thought: \(error.localizedDescription)")
                
                DispatchQueue.main.async {
                    self.isProcessing = false
                }
            }
        }
    }
    
    func applySuggestion(_ suggestion: CategorySuggestion, to thought: Thought, in context: NSManagedObjectContext) {
        if suggestion.exists {
            // Find and add existing category
            let request = NSFetchRequest<Category>(entityName: "Category")
            request.predicate = NSPredicate(format: "name == %@", suggestion.name)
            
            do {
                let categories = try context.fetch(request)
                if let category = categories.first {
                    thought.addToCategories(category)
                    try context.save()
                }
            } catch {
                print("Error applying existing category: \(error.localizedDescription)")
            }
        } else {
            // Create and add new category
            let category = Category.create(
                in: context,
                name: suggestion.name,
                colorHex: Category.randomColor(),
                isAutoGenerated: true
            )
            
            thought.addToCategories(category)
            
            do {
                try context.save()
            } catch {
                print("Error creating new category: \(error.localizedDescription)")
            }
        }
    }
}

struct CategorySuggestion: Identifiable {
    let id = UUID()
    let name: String
    let confidence: Float
    let exists: Bool
    
    var formattedConfidence: String {
        let percentage = Int(confidence * 100)
        return "\(percentage)%"
    }
}



### ./YapNotes/ViewModels/SearchViewModel.swift

import SwiftUI
import CoreData
import Combine

class SearchViewModel: ObservableObject {
    @Published var searchText = ""
    @Published var searchResults: [Thought] = []
    @Published var isSearching = false
    
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        // Debounce search text changes
        $searchText
            .debounce(for: .milliseconds(300), scheduler: RunLoop.main)
            .removeDuplicates()
            .compactMap { $0 }
            .sink { [weak self] searchText in
                if !searchText.isEmpty {
                    self?.performSearch(searchText)
                } else {
                    self?.searchResults = []
                }
            }
            .store(in: &cancellables)
    }
    
    func performSearch(_ query: String, in context: NSManagedObjectContext) {
        guard !query.isEmpty else {
            searchResults = []
            return
        }
        
        isSearching = true
        
        // Create a background context for search
        let searchContext = context.parent!.newBackgroundContext()
        
        Task {
            let results = await withCheckedContinuation { continuation in
                searchContext.perform {
                    let request = NSFetchRequest<Thought>(entityName: "Thought")
                    request.predicate = NSPredicate(
                        format: "transcription CONTAINS[cd] %@",
                        query
                    )
                    request.sortDescriptors = [
                        NSSortDescriptor(keyPath: \Thought.createdAt, ascending: false)
                    ]
                    
                    do {
                        let thoughts = try searchContext.fetch(request)
                        // Convert to object IDs to safely pass between contexts
                        let thoughtIDs = thoughts.map { $0.objectID }
                        continuation.resume(returning: thoughtIDs)
                    } catch {
                        print("Error performing search: \(error.localizedDescription)")
                        continuation.resume(returning: [])
                    }
                }
            }
            
            // Convert object IDs back to objects in the main context
            let finalResults = results.compactMap { context.object(with: $0) as? Thought }
            
            DispatchQueue.main.async {
                self.searchResults = finalResults
                self.isSearching = false
            }
        }
    }
    
    private func performSearch(_ query: String) {
        // This method is called from the Combine pipeline
        // We need a context to perform the search, which will be provided by the view
        // using the performSearch(_:in:) method
    }
}





### ./YapNotes/Services/AudioService.swift

import Foundation
import AVFoundation

class AudioService: NSObject {
    static let shared = AudioService()
    
    private let audioSession = AVAudioSession.sharedInstance()
    private var audioRecorder: AVAudioRecorder?
    
    private override init() {
        super.init()
        setupAudioSession()
    }
    
    func startRecording() throws -> URL {
        // Activate audio session
        try audioSession.setActive(true, options: .notifyOthersOnDeactivation)
        
        // Create output file URL
        let outputURL = getDocumentsDirectory().appendingPathComponent("\(UUID().uuidString).m4a")
        
        // Configure recorder
        let settings = [
            AVFormatIDKey: Int(kAudioFormatMPEG4AAC),
            AVSampleRateKey: 16000,
            AVNumberOfChannelsKey: 1,
            AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue
        ]
        
        // Start recording
        audioRecorder = try AVAudioRecorder(url: outputURL, settings: settings)
        audioRecorder?.record()
        
        return outputURL
    }
    
    func stopRecording() -> URL? {
        let url = audioRecorder?.url
        audioRecorder?.stop()
        audioRecorder = nil
        
        // Deactivate audio session
        try? audioSession.setActive(false, options: .notifyOthersOnDeactivation)
        
        return url
    }
    
    private func setupAudioSession() {
        do {
            try audioSession.setCategory(.playAndRecord, mode: .default)
            try audioSession.setActive(true)
        } catch {
            print("Failed to set up audio session: \(error.localizedDescription)")
        }
    }
    
    func getDocumentsDirectory() -> URL {
        let paths = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)
        let documentsDirectory = paths[0].appendingPathComponent("Audio", isDirectory: true)
        
        // Create Audio directory if it doesn't exist
        if !FileManager.default.fileExists(atPath: documentsDirectory.path) {
            try? FileManager.default.createDirectory(at: documentsDirectory, withIntermediateDirectories: true)
        }
        
        return documentsDirectory
    }
    
    func checkPermission(completion: @escaping (Bool) -> Void) {
        audioSession.requestRecordPermission { granted in
            DispatchQueue.main.async {
                completion(granted)
            }
        }
    }
    
    func deleteAudioFile(at url: URL) {
        try? FileManager.default.removeItem(at: url)
    }
    
    func getAllAudioFiles() -> [URL] {
        let audioDir = getDocumentsDirectory()
        
        do {
            let fileURLs = try FileManager.default.contentsOfDirectory(
                at: audioDir,
                includingPropertiesForKeys: nil
            )
            return fileURLs.filter { $0.pathExtension == "m4a" }
        } catch {
            print("Error getting audio files: \(error.localizedDescription)")
            return []
        }
    }
    
    func deleteAllAudioFiles() -> Bool {
        let audioDir = getDocumentsDirectory()
        
        do {
            let fileURLs = try FileManager.default.contentsOfDirectory(
                at: audioDir,
                includingPropertiesForKeys: nil
            )
            
            for fileURL in fileURLs {
                try FileManager.default.removeItem(at: fileURL)
            }
            
            return true
        } catch {
            print("Error deleting audio files: \(error.localizedDescription)")
            return false
        }
    }
}



### ./YapNotes/Services/TranscriptionService.swift

import Foundation
import Speech

enum TranscriptionError: Error {
    case audioFileError
    case transcriptionFailed
    case speechRecognitionNotAvailable
    case whisperModelNotLoaded
}

class TranscriptionService {
    static let shared = TranscriptionService()
    
    private let speechRecognizer = SFSpeechRecognizer(locale: Locale(identifier: "en-US"))
    private let whisperService = WhisperService.shared
    
    private init() {}
    
    func transcribeWithAppleSpeech(audioURL: URL) async throws -> String {
        guard SFSpeechRecognizer.authorizationStatus() == .authorized,
              let recognizer = speechRecognizer,
              recognizer.isAvailable else {
            throw TranscriptionError.speechRecognitionNotAvailable
        }
        
        let request = SFSpeechURLRecognitionRequest(url: audioURL)
        request.shouldReportPartialResults = false
        
        return try await withCheckedThrowingContinuation { continuation in
            recognizer.recognitionTask(with: request) { result, error in
                if let error = error {
                    continuation.resume(throwing: error)
                    return
                }
                
                guard let result = result else {
                    continuation.resume(throwing: TranscriptionError.transcriptionFailed)
                    return
                }
                
                if result.isFinal {
                    continuation.resume(returning: result.bestTranscription.formattedString)
                }
            }
        }
    }
    
    func transcribeWithWhisper(audioURL: URL) async throws -> String {
        try await whisperService.transcribe(audioPath: audioURL)
    }
    
    func transcribe(audioURL: URL) async throws -> String {
        // First try the more reliable WhisperCPP
        do {
            return try await whisperService.transcribe(audioPath: audioURL)
        } catch {
            // Fall back to Apple's Speech framework
            return try await transcribeWithAppleSpeech(audioURL: audioURL)
        }
    }
    
    // Combined approach that starts with quick Apple transcription
    // and then runs more accurate Whisper in the background
    func transcribeWithProgressiveAccuracy(audioURL: URL, progressHandler: @escaping (String) -> Void) async throws -> String {
        // Start Apple transcription for immediate feedback
        let appleTask = Task {
            do {
                let quickResult = try await transcribeWithAppleSpeech(audioURL: audioURL)
                progressHandler(quickResult)
                return quickResult
            } catch {
                return ""
            }
        }
        
        // In parallel, start the more accurate WhisperCPP transcription
        let whisperResult = try await whisperService.transcribe(audioPath: audioURL)
        
        // Cancel Apple task if it's still running (we already have better results)
        appleTask.cancel()
        
        return whisperResult
    }
    
    // Request speech recognition permission
    func requestSpeechRecognitionPermission() async -> Bool {
        return await withCheckedContinuation { continuation in
            SFSpeechRecognizer.requestAuthorization { status in
                continuation.resume(returning: status == .authorized)
            }
        }
    }
}



### ./YapNotes/Services/WhisperService.swift

import Foundation

class WhisperService {
    static let shared = WhisperService()
    
    private var isModelLoaded = false
    private let modelManager = MLModelManager.shared
    
    // Holds the C pointer to Whisper context (from bridge)
    private var whisperContext: OpaquePointer?
    
    private init() {
        loadModel()
    }
    
    func loadModel() {
        Task {
            do {
                // First check if we have the default model
                guard let modelURL = try await modelManager.getModelURL(type: .whisperTiny) else {
                    throw NSError(domain: "WhisperService", code: 1, userInfo: [NSLocalizedDescriptionKey: "Whisper model not found"])
                }
                
                // Use bridge to load model
                whisperContext = WhisperBridge.loadModel(modelURL.path)
                isModelLoaded = whisperContext != nil
            } catch {
                print("Failed to load Whisper model: \(error.localizedDescription)")
            }
        }
    }
    
    func transcribe(audioPath: URL) async throws -> String {
        // Make sure model is loaded
        if !isModelLoaded || whisperContext == nil {
            try await loadModelIfNeeded()
        }
        
        guard let context = whisperContext else {
            throw NSError(domain: "WhisperService", code: 2, userInfo: [NSLocalizedDescriptionKey: "Whisper context not initialized"])
        }
        
        return try await withCheckedThrowingContinuation { continuation in
            // Run transcription on a background thread
            DispatchQueue.global(qos: .userInitiated).async {
                let result = WhisperBridge.transcribeAudio(context, audioPath.path)
                
                if result.isEmpty {
                    continuation.resume(throwing: NSError(domain: "WhisperService", code: 3, userInfo: [NSLocalizedDescriptionKey: "Transcription failed"]))
                } else {
                    continuation.resume(returning: result)
                }
            }
        }
    }
    
    private func loadModelIfNeeded() async throws {
        // Try to load the best available model based on device capabilities
        var modelURL: URL?
        
        // If user has premium and better model is downloaded, use it
        if modelManager.subscriptionManager.isPremium && modelManager.isModelDownloaded(.whisperBase) {
            modelURL = try await modelManager.getModelURL(type: .whisperBase)
        } else {
            // Fallback to tiny model
            modelURL = try await modelManager.getModelURL(type: .whisperTiny)
        }
        
        guard let url = modelURL else {
            throw NSError(domain: "WhisperService", code: 1, userInfo: [NSLocalizedDescriptionKey: "No Whisper model available"])
        }
        
        // Unload previous model if any
        if whisperContext != nil {
            WhisperBridge.freeModel(whisperContext)
            whisperContext = nil
        }
        
        // Load new model
        whisperContext = WhisperBridge.loadModel(url.path)
        isModelLoaded = whisperContext != nil
        
        if !isModelLoaded {
            throw NSError(domain: "WhisperService", code: 4, userInfo: [NSLocalizedDescriptionKey: "Failed to load Whisper model"])
        }
    }
    
    deinit {
        if let context = whisperContext {
            WhisperBridge.freeModel(context)
        }
    }
}

### ./YapNotes/Services/OrganizationService.swift

import Foundation
import CoreData
import NaturalLanguage

class OrganizationService {
    static let shared = OrganizationService()
    
    private let modelManager = MLModelManager.shared
    private let mobileBERTService = MobileBERTService.shared
    private let miniLMService = MiniLMService.shared
    
    private init() {}
    
    func processNewThought(_ thought: Thought) async throws {
        // Get managed object context
        guard let context = thought.managedObjectContext else {
            throw NSError(domain: "OrganizationService", code: 1, userInfo: [NSLocalizedDescriptionKey: "No managed object context for thought"])
        }
        
        // Process in the correct context
        try await context.perform {
            // 1. Extract entities and key concepts
            let entities = try await self.extractEntities(from: thought.transcription ?? "")
            
            // 2. Generate embeddings for semantic similarity
            if let embeddings = try await self.generateEmbeddings(for: thought.transcription ?? "") {
                thought.embeddings = embeddings
            }
            
            // 3. Auto-generate tags
            let tags = entities.map { $0.string }
            thought.addTags(tags)
            
            // 4. Suggest categories
            let suggestedCategories = try await self.suggestCategories(for: thought.transcription ?? "")
            
            // 5. Find related thoughts
            let relatedThoughts = try await self.findRelatedThoughts(for: thought)
            
            // 6. Apply auto-created categories
            try self.applyAutoCategories(thought, suggestions: suggestedCategories)
            
            // 7. Create relationships with related thoughts
            for relatedThought in relatedThoughts {
                thought.addToRelatedThoughts(relatedThought)
                relatedThought.addToRelatedThoughts(thought)
            }
        }
    }
    
    func processThought(_ thought: Thought, in context: NSManagedObjectContext) async throws -> ([CategorySuggestion], [Thought]) {
        // 1. Extract entities from text
        let entities = try await extractEntities(from: thought.transcription ?? "")
        
        // 2. Generate embeddings if needed
        if thought.embeddings == nil {
            if let embeddings = try await generateEmbeddings(for: thought.transcription ?? "") {
                await context.perform {
                    thought.embeddings = embeddings
                }
            }
        }
        
        // 3. Suggest categories
        let categorySuggestions = try await suggestCategoriesWithExistingCheck(
            for: thought.transcription ?? "",
            in: context
        )
        
        // 4. Find related thoughts
        let relatedThoughts = try await findRelatedThoughts(for: thought)
        
        return (categorySuggestions, relatedThoughts)
    }
    
    // MARK: - Entity Extraction
    
    func extractEntities(from text: String) async throws -> [NLEntity] {
        let tagger = NLTagger(tagSchemes: [.nameType])
        tagger.string = text
        
        var entities: [NLEntity] = []
        
        let options: NLTagger.Options = [.omitPunctuation, .omitWhitespace, .joinNames]
        let tags: [NLTag] = [.personalName, .placeName, .organizationName]
        
        tagger.enumerateTags(in: text.startIndex..<text.endIndex, unit: .word, scheme: .nameType, options: options) { tag, tokenRange in
            if let tag = tag, tags.contains(tag) {
                let entity = NLEntity(
                    string: String(text[tokenRange]),
                    range: tokenRange,
                    type: tag
                )
                entities.append(entity)
            }
            return true
        }
        
        // Use MobileBERT for more advanced entity extraction if available
        if modelManager.isModelLoaded(.mobileBERT) {
            let bertEntities = try await mobileBERTService.extractEntities(from: text)
            entities.append(contentsOf: bertEntities)
        }
        
        return entities
    }
    
    // MARK: - Embedding Generation
    
    func generateEmbeddings(for text: String) async throws -> Data? {
        guard !text.isEmpty else { return nil }
        
        // If MiniLM is available, use it for better embeddings
        if modelManager.isModelLoaded(.miniLM) {
            return try await miniLMService.generateEmbeddings(for: text)
        }
        
        // Fallback to NLP embeddings
        let embedding = try await generateNLPEmbeddings(for: text)
        return try NSKeyedArchiver.archivedData(withRootObject: embedding, requiringSecureCoding: true)
    }
    
    private func generateNLPEmbeddings(for text: String) async throws -> [Float] {
        let embedding = NLEmbedding.sentenceEmbedding(for: .english)
        guard let vector = embedding?.vector(for: text) else {
            throw NSError(domain: "OrganizationService", code: 2, userInfo: [NSLocalizedDescriptionKey: "Failed to generate embeddings"])
        }
        
        return vector
    }
    
    // MARK: - Category Suggestion
    
    func suggestCategories(for text: String) async throws -> [(name: String, confidence: Float)] {
        var categories: [(name: String, confidence: Float)] = []
        
        // Use Natural Language for initial categorization
        let tagger = NLTagger(tagSchemes: [.lexicalClass])
        tagger.string = text
        
        // Extract keywords to suggest categories
        var keywordCounts: [String: Int] = [:]
        
        tagger.enumerateTags(in: text.startIndex..<text.endIndex, unit: .word, scheme: .lexicalClass, options: [.omitPunctuation, .omitWhitespace]) { tag, range in
            if let tag = tag, tag == .noun || tag == .verb {
                let word = String(text[range]).lowercased()
                if word.count > 3 {  // Filter short words
                    keywordCounts[word, default: 0] += 1
                }
            }
            return true
        }
        
        // Generate potential categories from top keywords
        let sortedKeywords = keywordCounts.sorted { $0.value > $1.value }.prefix(5)
        for (keyword, count) in sortedKeywords {
            let confidence = min(Float(count) / 10.0, 1.0)
            categories.append((keyword.capitalized, confidence))
        }
        
        // If MobileBERT is available, use it for better category suggestions
        if modelManager.isModelLoaded(.mobileBERT) {
            let bertCategories = try await mobileBERTService.suggestCategories(for: text)
            categories.append(contentsOf: bertCategories)
        }
        
        // Remove duplicates and sort by confidence
        var uniqueCategories: [(name: String, confidence: Float)] = []
        var seenNames = Set<String>()
        
        for category in categories.sorted(by: { $0.confidence > $1.confidence }) {
            if !seenNames.contains(category.name) {
                uniqueCategories.append(category)
                seenNames.insert(category.name)
            }
        }
        
        return Array(uniqueCategories.prefix(3))
    }
    
    func suggestCategoriesWithExistingCheck(for text: String, in context: NSManagedObjectContext) async throws -> [CategorySuggestion] {
        // Get suggested categories
        let suggestedCategories = try await suggestCategories(for: text)
        
        // Fetch existing categories
        let fetchRequest = NSFetchRequest<Category>(entityName: "Category")
        fetchRequest.predicate = NSPredicate(format: "name IN %@", suggestedCategories.map { $0.name })
        
        let existingCategories = try await context.perform {
            try context.fetch(fetchRequest)
        }
        
        let existingCategoryNames = Set(existingCategories.compactMap { $0.name })
        
        // Create category suggestions with existence check
        return suggestedCategories.map { suggestion in
            CategorySuggestion(
                name: suggestion.name,
                confidence: suggestion.confidence,
                exists: existingCategoryNames.contains(suggestion.name)
            )
        }
    }
    
    // MARK: - Related Thoughts
    
    func findRelatedThoughts(for thought: Thought) async throws -> [Thought] {
        guard let embeddings = thought.embeddings,
              let context = thought.managedObjectContext else {
            return []
        }
        
        // Fetch all thoughts except the current one
        let fetchRequest = NSFetchRequest<Thought>(entityName: "Thought")
        fetchRequest.predicate = NSPredicate(format: "uuid != %@", thought.uuid! as CVarArg)
        
        let allThoughts = try await context.perform {
            try context.fetch(fetchRequest)
        }
        
        // Calculate similarity with each thought
        var thoughtsWithSimilarity: [(thought: Thought, similarity: Float)] = []
        
        for otherThought in allThoughts {
            guard let otherEmbeddings = otherThought.embeddings else { continue }
            
            let similarity = try await calculateCosineSimilarity(
                embeddings1: embeddings,
                embeddings2: otherEmbeddings
            )
            
            thoughtsWithSimilarity.append((otherThought, similarity))
        }
        
        // Return top 5 most similar thoughts
        return thoughtsWithSimilarity
            .sorted(by: { $0.similarity > $1.similarity })
            .prefix(5)
            .map { $0.thought }
    }
    
    private func calculateCosineSimilarity(embeddings1: Data, embeddings2: Data) async throws -> Float {
        // Load vector from archive data
        let vector1 = try NSKeyedUnarchiver.unarchivedObject(
            ofClass: NSArray.self,
            from: embeddings1
        ) as? [Float] ?? []
        
        let vector2 = try NSKeyedUnarchiver.unarchivedObject(
            ofClass: NSArray.self,
            from: embeddings2
        ) as? [Float] ?? []
        
        guard vector1.count == vector2.count, !vector1.isEmpty else {
            return 0
        }
        
        // Calculate dot product
        var dotProduct: Float = 0.0
        var magnitude1: Float = 0.0
        var magnitude2: Float = 0.0
        
        for i in 0..<vector1.count {
            dotProduct += vector1[i] * vector2[i]
            magnitude1 += vector1[i] * vector1[i]
            magnitude2 += vector2[i] * vector2[i]
        }
        
        magnitude1 = sqrt(magnitude1)
        magnitude2 = sqrt(magnitude2)
        
        if magnitude1 > 0 && magnitude2 > 0 {
            return dotProduct / (magnitude1 * magnitude2)
        } else {
            return 0
        }
    }
    
    // MARK: - Auto Categorization
    
    private func applyAutoCategories(_ thought: Thought, suggestions: [(name: String, confidence: Float)]) throws {
        guard let context = thought.managedObjectContext else { return }
        
        // Apply only suggestions with high confidence
        let highConfidenceSuggestions = suggestions.filter { $0.confidence >= 0.7 }
        
        for suggestion in highConfidenceSuggestions {
            // Check if category already exists
            let fetchRequest = NSFetchRequest<Category>(entityName: "Category")
            fetchRequest.predicate = NSPredicate(format: "name == %@", suggestion.name)
            
            let existingCategories = try context.fetch(fetchRequest)
            
            if let existingCategory = existingCategories.first {
                // Add thought to existing category
                thought.addToCategories(existingCategory)
            } else {
                // Create new auto-generated category
                let newCategory = Category.create(
                    in: context,
                    name: suggestion.name,
                    colorHex: Category.randomColor(),
                    isAutoGenerated: true
                )
                
                thought.addToCategories(newCategory)
            }
        }
    }
}



### ./YapNotes/Services/MobileBERTService.swift

import Foundation
import CoreML
import NaturalLanguage

enum MobileBERTError: Error {
    case modelNotAvailable
    case processingFailed
    case invalidInput
}

class MobileBERTService {
    static let shared = MobileBERTService()
    
    private let modelManager = MLModelManager.shared
    private var model: MLModel?
    
    private init() {
        loadModel()
    }
    
    func loadModel() {
        Task {
            do {
                if modelManager.isModelLoaded(.mobileBERT) {
                    if let modelURL = try await modelManager.getModelURL(type: .mobileBERT) {
                        model = try MLModel(contentsOf: modelURL)
                    }
                }
            } catch {
                print("Failed to load MobileBERT model: \(error.localizedDescription)")
            }
        }
    }
    
    func extractEntities(from text: String) async throws -> [NLEntity] {
        guard modelManager.isModelLoaded(.mobileBERT) else {
            throw MobileBERTError.modelNotAvailable
        }
        
        // Ensure model is loaded
        if model == nil {
            loadModel()
        }
        
        guard let model = model else {
            throw MobileBERTError.modelNotAvailable
        }
        
        // Prepare input for the model
        let tokenizer = BERTTokenizer()
        let tokenizedInput = tokenizer.tokenize(text: text, maxLength: 128)
        
        // Create MLFeatureProvider for prediction
        let inputFeatures = try MLDictionaryFeatureProvider(dictionary: [
            "input_ids": MLMultiArray(tokenizedInput.inputIds),
            "attention_mask": MLMultiArray(tokenizedInput.attentionMask),
            "token_type_ids": MLMultiArray(tokenizedInput.tokenTypeIds)
        ])
        
        // Perform prediction
        let output = try model.prediction(from: inputFeatures)
        
        // Process results to extract entities
        let entityIndices = extractEntityIndices(
            from: output.featureValue(for: "sequence_output")?.multiArrayValue,
            tokens: tokenizedInput.tokens
        )
        
        // Convert entity indices to NLEntity objects
        return constructEntities(from: entityIndices, originalText: text)
    }
    
    func suggestCategories(for text: String) async throws -> [(name: String, confidence: Float)] {
        guard modelManager.isModelLoaded(.mobileBERT) else {
            return []
        }
        
        // Ensure model is loaded
        if model == nil {
            loadModel()
        }
        
        guard let model = model else {
            return []
        }
        
        // Prepare prompt for category extraction
        let prompt = "Extract categories from this text: \(text)\nCategories:"
        
        let tokenizer = BERTTokenizer()
        let tokenizedInput = tokenizer.tokenize(text: prompt, maxLength: 256)
        
        // Create MLFeatureProvider for prediction
        let inputFeatures = try MLDictionaryFeatureProvider(dictionary: [
            "input_ids": MLMultiArray(tokenizedInput.inputIds),
            "attention_mask": MLMultiArray(tokenizedInput.attentionMask),
            "token_type_ids": MLMultiArray(tokenizedInput.tokenTypeIds)
        ])
        
        // Perform prediction
        let output = try model.prediction(from: inputFeatures)
        
        // Process results to extract category suggestions
        guard let predictions = output.featureValue(for: "sequence_output")?.multiArrayValue else {
            return []
        }
        
        // Extract category text from output
        let categoryText = extractPredictedText(
            from: predictions,
            tokens: tokenizedInput.tokens
        )
        
        // Parse categories and confidence
        return parseCategories(from: categoryText)
    }
    
    // MARK: - Helper Functions
    
    private func extractEntityIndices(from output: MLMultiArray?, tokens: [String]) -> [(start: Int, end: Int, type: String)] {
        // Implementation would use the model output to identify entity spans
        // This is a simplified version that returns entity indices
        var entities: [(start: Int, end: Int, type: String)] = []
        
        // The actual implementation would analyze the output tensor to find entity spans
        // For example, using a sequence labeling approach (BIO tagging)
        
        return entities
    }
    
    private func constructEntities(from entityIndices: [(start: Int, end: Int, type: String)], originalText: String) -> [NLEntity] {
        var entities: [NLEntity] = []
        
        for entityIndex in entityIndices {
            let range = findRange(for: entityIndex, in: originalText)
            let entityText = String(originalText[range])
            
            let entity = NLEntity(
                string: entityText,
                range: range,
                type: mapEntityType(entityIndex.type)
            )
            
            entities.append(entity)
        }
        
        return entities
    }
    
    private func findRange(for entityIndex: (start: Int, end: Int, type: String), in text: String) -> Range<String.Index> {
        // This function would convert token indices to character ranges
        // Simplified implementation that returns full text range
        return text.startIndex..<text.endIndex
    }
    
    private func mapEntityType(_ type: String) -> NLTag {
        // Map BERT entity types to NLTag
        switch type {
        case "PERSON":
            return .personalName
        case "LOCATION":
            return .placeName
        case "ORGANIZATION":
            return .organizationName
        default:
            return .otherWord
        }
    }
    
    private func extractPredictedText(from predictions: MLMultiArray, tokens: [String]) -> String {
        // This function would extract predicted text from the model output
        // Simplified implementation that returns a mock result
        return "Work, Ideas, Personal"
    }
    
    private func parseCategories(from text: String) -> [(name: String, confidence: Float)] {
        // Parse the predicted categories and assign confidence
        let categories = text.components(separatedBy: ",")
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
            .filter { !$0.isEmpty }
        
        // Assign decreasing confidence based on order
        var result: [(name: String, confidence: Float)] = []
        
        for (index, category) in categories.enumerated() {
            let confidence = max(1.0 - Float(index) * 0.1, 0.6)
            result.append((category, confidence))
        }
        
        return result
    }
}

// BERT Tokenizer Helper
class BERTTokenizer {
    struct TokenizedInput {
        let inputIds: [Int32]
        let attentionMask: [Int32]
        let tokenTypeIds: [Int32]
        let tokens: [String]
    }
    
    func tokenize(text: String, maxLength: Int) -> TokenizedInput {
        // This would be a proper BERT tokenizer implementation
        // Simplified mock implementation for demonstration purposes
        
        let tokens = text.components(separatedBy: .whitespacesAndNewlines)
        let truncatedTokens = Array(tokens.prefix(maxLength - 2)) // Account for [CLS] and [SEP]
        
        let allTokens = ["[CLS]"] + truncatedTokens + ["[SEP]"]
        let paddedLength = min(maxLength, allTokens.count)
        
        var inputIds: [Int32] = Array(repeating: 0, count: maxLength)
        var attentionMask: [Int32] = Array(repeating: 0, count: maxLength)
        var tokenTypeIds: [Int32] = Array(repeating: 0, count: maxLength)
        
        // Fill arrays with mock values
        for i in 0..<paddedLength {
            inputIds[i] = Int32(i + 1) // Mocked token IDs
            attentionMask[i] = 1 // 1 for real tokens
            tokenTypeIds[i] = 0 // All 0 for single sentence
        }
        
        return TokenizedInput(
            inputIds: inputIds,
            attentionMask: attentionMask,
            tokenTypeIds: tokenTypeIds,
            tokens: allTokens
        )
    }
}

extension MLMultiArray {
    convenience init(_ values: [Int32]) {
        try! self.init(shape: [NSNumber(value: values.count)], dataType: .int32)
        for (index, element) in values.enumerated() {
            self[index] = NSNumber(value: element)
        }
    }
}



### ./YapNotes/Services/MiniLMService.swift

import Foundation
import CoreML
import NaturalLanguage

enum MiniLMError: Error {
    case modelNotAvailable
    case processingFailed
    case invalidInput
}

class MiniLMService {
    static let shared = MiniLMService()
    
    private let modelManager = MLModelManager.shared
    private var model: MLModel?
    
    private init() {
        loadModel()
    }
    
    func loadModel() {
        Task {
            do {
                if modelManager.isModelLoaded(.miniLM) {
                    if let modelURL = try await modelManager.getModelURL(type: .miniLM) {
                        model = try MLModel(contentsOf: modelURL)
                    }
                }
            } catch {
                print("Failed to load MiniLM model: \(error.localizedDescription)")
            }
        }
    }
    
    func generateEmbeddings(for text: String) async throws -> Data? {
        guard !text.isEmpty else {
            return nil
        }
        
        // If model is not available, fall back to NLP embeddings
        guard modelManager.isModelLoaded(.miniLM) else {
            return try await generateNLPEmbeddings(for: text)
        }
        
        // Ensure model is loaded
        if model == nil {
            loadModel()
        }
        
        guard let model = model else {
            return try await generateNLPEmbeddings(for: text)
        }
        
        // Tokenize input text
        let tokenizer = SentenceTransformerTokenizer()
        let tokenizedInput = tokenizer.tokenize(text: text, maxLength: 128)
        
        // Create MLFeatureProvider for prediction
        let inputFeatures = try MLDictionaryFeatureProvider(dictionary: [
            "input_ids": MLMultiArray(tokenizedInput.inputIds),
            "attention_mask": MLMultiArray(tokenizedInput.attentionMask),
            "token_type_ids": MLMultiArray(tokenizedInput.tokenTypeIds)
        ])
        
        // Perform prediction
        let output = try model.prediction(from: inputFeatures)
        
        // Extract embeddings from output
        guard let embeddingsArray = output.featureValue(for: "sentence_embedding")?.multiArrayValue else {
            throw MiniLMError.processingFailed
        }
        
        // Convert MLMultiArray to [Float]
        let embeddings = Array(UnsafeBufferPointer<Float>(
            start: embeddingsArray.dataPointer.assumingMemoryBound(to: Float.self),
            count: embeddingsArray.count
        ))
        
        // Archive embeddings
        return try NSKeyedArchiver.archivedData(withRootObject: embeddings as NSArray, requiringSecureCoding: true)
    }
    
    private func generateNLPEmbeddings(for text: String) async throws -> Data? {
        // Fallback to NLP embeddings if model is not available
        guard let embedding = NLEmbedding.sentenceEmbedding(for: .english) else {
            throw MiniLMError.processingFailed
        }
        
        guard let vector = embedding.vector(for: text) else {
            throw MiniLMError.processingFailed
        }
        
        // Archive embeddings
        return try NSKeyedArchiver.archivedData(withRootObject: vector as NSArray, requiringSecureCoding: true)
    }
    
    // Function to find related sentences based on embeddings
    func findSimilarSentences(sourceEmbeddings: Data, candidateTexts: [String]) async throws -> [(text: String, similarity: Float)] {
        let sourceVector = try NSKeyedUnarchiver.unarchivedObject(
            ofClass: NSArray.self,
            from: sourceEmbeddings
        ) as? [Float] ?? []
        
        var results: [(text: String, similarity: Float)] = []
        
        for text in candidateTexts {
            guard !text.isEmpty else { continue }
            
            if let embeddings = try await generateEmbeddings(for: text) {
                let candidateVector = try NSKeyedUnarchiver.unarchivedObject(
                    ofClass: NSArray.self,
                    from: embeddings
                ) as? [Float] ?? []
                
                let similarity = cosineSimilarity(a: sourceVector, b: candidateVector)
                results.append((text, similarity))
            }
        }
        
        return results.sorted(by: { $0.similarity > $1.similarity })
    }
    
    private func cosineSimilarity(a: [Float], b: [Float]) -> Float {
        guard a.count == b.count, !a.isEmpty else {
            return 0
        }
        
        var dotProduct: Float = 0.0
        var magnitudeA: Float = 0.0
        var magnitudeB: Float = 0.0
        
        for i in 0..<a.count {
            dotProduct += a[i] * b[i]
            magnitudeA += a[i] * a[i]
            magnitudeB += b[i] * b[i]
        }
        
        magnitudeA = sqrt(magnitudeA)
        magnitudeB = sqrt(magnitudeB)
        
        if magnitudeA > 0 && magnitudeB > 0 {
            return dotProduct / (magnitudeA * magnitudeB)
        } else {
            return 0
        }
    }
}

// Helper Tokenizer for Sentence Transformer models
class SentenceTransformerTokenizer {
    struct TokenizedInput {
        let inputIds: [Int32]
        let attentionMask: [Int32]
        let tokenTypeIds: [Int32]
    }
    
    func tokenize(text: String, maxLength: Int) -> TokenizedInput {
        // This would be a proper transformer tokenizer implementation
        // Simplified mock implementation for demonstration purposes
        
        let tokens = text.components(separatedBy: .whitespacesAndNewlines)
        let truncatedLength = min(maxLength - 2, tokens.count) // Account for [CLS] and [SEP]
        
        let paddedLength = maxLength
        
        var inputIds: [Int32] = Array(repeating: 0, count: paddedLength)
        var attentionMask: [Int32] = Array(repeating: 0, count: paddedLength)
        var tokenTypeIds: [Int32] = Array(repeating: 0, count: paddedLength)
        
        // Fill arrays with mock values (simplified)
        inputIds[0] = 101 // [CLS] token ID
        attentionMask[0] = 1
        tokenTypeIds[0] = 0
        
        for i in 0..<truncatedLength {
            inputIds[i + 1] = Int32(i + 1000) // Mocked token IDs
            attentionMask[i + 1] = 1 // 1 for real tokens
            tokenTypeIds[i + 1] = 0 // All 0 for single sentence
        }
        
        inputIds[truncatedLength + 1] = 102 // [SEP] token ID
        attentionMask[truncatedLength + 1] = 1
        tokenTypeIds[truncatedLength + 1] = 0
        
        return TokenizedInput(
            inputIds: inputIds,
            attentionMask: attentionMask,
            tokenTypeIds: tokenTypeIds
        )
    }
}



### ./YapNotes/Services/MLModelManager.swift

import Foundation
import Combine

enum ModelType: String, CaseIterable, Identifiable {
    case whisperTiny
    case whisperBase
    case mobileBERT
    case miniLM
    
    var id: String {
        return rawValue
    }
    
    var displayName: String {
        switch self {
        case .whisperTiny:
            return "Whisper Tiny"
        case .whisperBase:
            return "Whisper Base"
        case .mobileBERT:
            return "MobileBERT"
        case .miniLM:
            return "MiniLM"
        }
    }
    
    var description: String {
        switch self {
        case .whisperTiny:
            return "Basic transcription (39MB)"
        case .whisperBase:
            return "Better accuracy (74MB)"
        case .mobileBERT:
            return "Text understanding (25MB)"
        case .miniLM:
            return "Semantic search (22MB)"
        }
    }
    
    var fileName: String {
        switch self {
        case .whisperTiny:
            return "whisper-tiny.bin"
        case .whisperBase:
            return "whisper-base.bin"
        case .mobileBERT:
            return "mobilebert.mlmodel"
        case .miniLM:
            return "minilm.mlmodel"
        }
    }
    
    var sizeInMB: Int {
        switch self {
        case .whisperTiny:
            return 39
        case .whisperBase:
            return 74
        case .mobileBERT:
            return 25
        case .miniLM:
            return 22
        }
    }
    
    var requiresPremium: Bool {
        switch self {
        case .whisperTiny, .mobileBERT:
            return false
        case .whisperBase, .miniLM:
            return true
        }
    }
    
    var sizeString: String {
        return "\(sizeInMB) MB"
    }
    
    var cdnURL: URL {
        URL(string: "https://cdn.yapnotes.app/models/\(fileName)")!
    }
}

class MLModelManager: ObservableObject {
    static let shared = MLModelManager()
    
    @Published var downloadingModels: Set<ModelType> = []
    @Published var downloadProgressDict: [ModelType: Double] = [:]
    @Published var downloadedModels: [ModelType] = []
    
    var subscriptionManager: SubscriptionManager {
        return SubscriptionManager.shared
    }
    
    private var cancellables = Set<AnyCancellable>()
    
    private init() {
        updateDownloadedModels()
    }
    
    // MARK: - Model Management
    
    func updateDownloadedModels() {
        let modelsDir = getModelsDirectory()
        
        do {
            let fileManager = FileManager.default
            let files = try fileManager.contentsOfDirectory(atPath: modelsDir.path)
            
            downloadedModels = ModelType.allCases.filter { modelType in
                files.contains(modelType.fileName)
            }
        } catch {
            print("Error checking downloaded models: \(error.localizedDescription)")
        }
    }
    
    func isModelDownloaded(_ modelType: ModelType) -> Bool {
        return downloadedModels.contains(modelType)
    }
    
    func isModelDownloading(_ modelType: ModelType) -> Bool {
        return downloadingModels.contains(modelType)
    }
    
    func isModelLoaded(_ modelType: ModelType) -> Bool {
        return isModelDownloaded(modelType)
    }
    
    func downloadProgress(for modelType: ModelType) -> Double {
        return downloadProgressDict[modelType] ?? 0.0
    }
    
    // MARK: - Model Download
    
    func downloadModel(_ modelType: ModelType) async throws {
        // Check if premium is required but not available
        if modelType.requiresPremium && !subscriptionManager.isPremium {
            throw NSError(domain: "MLModelManager", code: 1, userInfo: [NSLocalizedDescriptionKey: "Premium subscription required"])
        }
        
        // Check if already downloaded
        if isModelDownloaded(modelType) {
            return
        }
        
        // Check if already downloading
        guard !isModelDownloading(modelType) else {
            return
        }
        
        // Update state
        await MainActor.run {
            downloadingModels.insert(modelType)
            downloadProgressDict[modelType] = 0.0
        }
        
        do {
            // Create destination URL
            let modelsDir = getModelsDirectory()
            let destinationURL = modelsDir.appendingPathComponent(modelType.fileName)
            
            // Download from CDN
            let (downloadURL, _) = try await URLSession.shared.download(from: modelType.cdnURL) { progress in
                let progressValue = progress.fractionCompleted
                
                Task { @MainActor in
                    self.downloadProgressDict[modelType] = progressValue
                }
            }
            
            // Move temporary file to destination
            try FileManager.default.moveItem(at: downloadURL, to: destinationURL)
            
            // Update state
            await MainActor.run {
                downloadingModels.remove(modelType)
                updateDownloadedModels()
            }
        } catch {
            // Handle download error
            await MainActor.run {
                downloadingModels.remove(modelType)
                downloadProgressDict.removeValue(forKey: modelType)
            }
            
            throw error
        }
    }
    
    func deleteModel(_ modelType: ModelType) async -> Bool {
        // Prevent deleting the required tiny model
        if modelType == .whisperTiny {
            return false
        }
        
        let modelsDir = getModelsDirectory()
        let modelURL = modelsDir.appendingPathComponent(modelType.fileName)
        
        do {
            try FileManager.default.removeItem(at: modelURL)
            
            await MainActor.run {
                updateDownloadedModels()
            }
            
            return true
        } catch {
            print("Error deleting model: \(error.localizedDescription)")
            return false
        }
    }
    
    // MARK: - Model URL
    
    func getModelURL(type: ModelType) async throws -> URL? {
        let modelsDir = getModelsDirectory()
        let modelURL = modelsDir.appendingPathComponent(type.fileName)
        
        if FileManager.default.fileExists(atPath: modelURL.path) {
            return modelURL
        }
        
        // If model is a required one (tiny), download it
        if type == .whisperTiny {
            try await downloadModel(type)
            return modelsDir.appendingPathComponent(type.fileName)
        }
        
        return nil
    }
    
    // MARK: - Storage Management
    
    func ensureDefaultModelsExist() async {
        do {
            // Check if tiny model is already downloaded
            if !isModelDownloaded(.whisperTiny) {
                try await downloadModel(.whisperTiny)
            }
        } catch {
            print("Error ensuring default models exist: \(error.localizedDescription)")
        }
    }
    
    var totalStorageUsedFormatted: String {
        let totalSizeMB = downloadedModels.reduce(0) { $0 + $1.sizeInMB }
        let audioSize = Int(audioStorageUsed / (1024 * 1024))
        
        let totalSize = totalSizeMB + audioSize
        
        return "\(totalSize) MB"
    }
    
    var audioStorageUsed: UInt64 {
        let audioDir = AudioService.shared.getDocumentsDirectory()
        return directorySize(url: audioDir)
    }
    
    var audioStorageUsedFormatted: String {
        let size = audioStorageUsed
        
        if size < 1024 * 1024 {
            return "\(size / 1024) KB"
        } else {
            return "\(size / (1024 * 1024)) MB"
        }
    }
    
    var audioFileCount: Int {
        return AudioService.shared.getAllAudioFiles().count
    }
    
    private func directorySize(url: URL) -> UInt64 {
        let fileManager = FileManager.default
        
        guard let enumerator = fileManager.enumerator(at: url, includingPropertiesForKeys: [.fileSizeKey]) else {
            return 0
        }
        
        var size: UInt64 = 0
        
        for case let fileURL as URL in enumerator {
            guard let attributes = try? fileManager.attributesOfItem(atPath: fileURL.path),
                  let fileSize = attributes[.size] as? UInt64 else {
                continue
            }
            
            size += fileSize
        }
        
        return size
    }
    
    // MARK: - Directory Management
    
    private func getModelsDirectory() -> URL {
        let applicationSupportDirectory = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let modelsDirectory = applicationSupportDirectory.appendingPathComponent("Models", isDirectory: true)
        
        // Create directory if it doesn't exist
        if !FileManager.default.fileExists(atPath: modelsDirectory.path) {
            try? FileManager.default.createDirectory(at: modelsDirectory, withIntermediateDirectories: true)
        }
        
        return modelsDirectory
    }
}



### ./YapNotes/Services/SubscriptionManager.swift

import Foundation
import StoreKit

enum SubscriptionType: String {
    case monthly = "com.yapnotes.subscription.monthly"
    case yearly = "com.yapnotes.subscription.yearly"
}

enum SubscriptionError: Error {
    case purchaseFailed
    case productNotFound
    case paymentCancelled
    case notAuthorized
    case storeKitError(Error)
}

class SubscriptionManager: ObservableObject {
    static let shared = SubscriptionManager()
    
    @Published var isPremium = false
    @Published var products: [Product] = []
    @Published var isLoading = false
    
    private var productIDs = Set([
        "com.yapnotes.subscription.monthly",
        "com.yapnotes.subscription.yearly"
    ])
    
    private var updateListenerTask: Task<Void, Error>?
    
    private init() {
        updateListenerTask = listenForTransactionUpdates()
        
        Task {
            // Check subscription status on launch
            await updateSubscriptionStatus()
            
            // Load products
            await loadProducts()
        }
    }
    
    deinit {
        updateListenerTask?.cancel()
    }
    
    // MARK: - Products Loading
    
    @MainActor
    func loadProducts() async {
        isLoading = true
        
        do {
            products = try await Product.products(for: productIDs)
            isLoading = false
        } catch {
            print("Failed to load products: \(error.localizedDescription)")
            isLoading = false
        }
    }
    
    func getProduct(for type: SubscriptionType) -> Product? {
        return products.first { $0.id == type.rawValue }
    }
    
    // MARK: - Purchases
    
    @MainActor
    func purchaseSubscription(_ type: SubscriptionType) async -> Bool {
        guard let product = getProduct(for: type) else {
            return false
        }
        
        do {
            let result = try await purchase(product)
            return result
        } catch {
            print("Purchase failed: \(error.localizedDescription)")
            return false
        }
    }
    
    @MainActor
    private func purchase(_ product: Product) async throws -> Bool {
        // Start a purchase
        let result = try await product.purchase()
        
        switch result {
        case .success(let verification):
            // Check if the transaction is verified
            switch verification {
            case .verified(let transaction):
                // Transaction verified, finish it
                await transaction.finish()
                
                // Update subscription status
                isPremium = true
                return true
                
            case .unverified:
                // Transaction not verified
                throw SubscriptionError.purchaseFailed
            }
            
        case .userCancelled:
            throw SubscriptionError.paymentCancelled
            
        case .pending:
            // Transaction pending (e.g., parental approval)
            return false
            
        @unknown default:
            throw SubscriptionError.storeKitError(NSError(domain: "SubscriptionManager", code: 0, userInfo: [NSLocalizedDescriptionKey: "Unknown purchase result"]))
        }
    }
    
    // MARK: - Transaction Handling
    
    private func listenForTransactionUpdates() -> Task<Void, Error> {
        return Task.detached {
            for await result in Transaction.updates {
                do {
                    let transaction = try self.checkVerified(result)
                    
                    // Update subscription status
                    await self.updateSubscriptionStatus()
                    
                    // Finish the transaction
                    await transaction.finish()
                } catch {
                    print("Transaction verification failed: \(error.localizedDescription)")
                }
            }
        }
    }
    
    private func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {
        switch result {
        case .verified(let safe):
            return safe
        case .unverified:
            throw SubscriptionError.notAuthorized
        }
    }
    
    // MARK: - Subscription Status
    
    @MainActor
    func updateSubscriptionStatus() async {
        do {
            var hasActiveSubscription = false
            
            // Check for active subscriptions
            for await result in Transaction.currentEntitlements {
                do {
                    let transaction = try checkVerified(result)
                    
                    if transaction.productID == SubscriptionType.monthly.rawValue ||
                       transaction.productID == SubscriptionType.yearly.rawValue {
                        
                        if transaction.revocationDate == nil &&
                           (transaction.expirationDate == nil || transaction.expirationDate! > Date()) {
                            hasActiveSubscription = true
                            break
                        }
                    }
                } catch {
                    print("Transaction verification failed: \(error.localizedDescription)")
                }
            }
            
            isPremium = hasActiveSubscription
        } catch {
            print("Failed to update subscription status: \(error.localizedDescription)")
        }
    }
    
    func restorePurchases() async throws {
        try await AppStore.sync()
        await updateSubscriptionStatus()
    }
}





### ./YapNotes/Services/Whisper/WhisperBridge.h

#ifndef WhisperBridge_h
#define WhisperBridge_h

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

// Opaque pointer to whisper context
typedef struct whisper_context whisper_context;

@interface WhisperBridge : NSObject

// Load the Whisper model from a file path
+ (whisper_context *)loadModel:(NSString *)path;

// Free the Whisper model context
+ (void)freeModel:(whisper_context *)context;

// Transcribe audio from a file path
+ (NSString *)transcribeAudio:(whisper_context *)context
                        path:(NSString *)path;

// Transcribe audio from a buffer
+ (NSString *)transcribeBuffer:(whisper_context *)context
                        buffer:(float *)buffer
                        length:(int)length;

@end

NS_ASSUME_NONNULL_END

#endif /* WhisperBridge_h */



### ./YapNotes/Services/Whisper/WhisperBridge.mm

#import "WhisperBridge.h"
#import <Accelerate/Accelerate.h>
#import <AVFoundation/AVFoundation.h>

// Include whisper.cpp
#include "whisper.cpp/whisper.h"

@implementation WhisperBridge

// Load the Whisper model
+ (whisper_context *)loadModel:(NSString *)path {
    // Load the model
    struct whisper_context_params cparams = whisper_context_default_params();
    struct whisper_context * ctx = whisper_init_from_file([path UTF8String], cparams);
    
    if (ctx == nullptr) {
        NSLog(@"Failed to load model: %@", path);
        return NULL;
    }
    
    return ctx;
}

// Free the Whisper model context
+ (void)freeModel:(whisper_context *)context {
    if (context != NULL) {
        whisper_free(context);
    }
}

// Transcribe audio from a file path
+ (NSString *)transcribeAudio:(whisper_context *)context path:(NSString *)path {
    if (context == NULL) {
        NSLog(@"Whisper context is NULL");
        return @"";
    }
    
    // Load and convert the audio file
    NSURL *audioURL = [NSURL fileURLWithPath:path];
    AVAudioFile *audioFile;
    
    @try {
        NSError *error = nil;
        audioFile = [[AVAudioFile alloc] initForReading:audioURL error:&error];
        
        if (error) {
            NSLog(@"Error loading audio file: %@", error);
            return @"";
        }
    } @catch (NSException *exception) {
        NSLog(@"Exception loading audio file: %@", exception);
        return @"";
    }
    
    // Get audio format
    AVAudioFormat *format = audioFile.processingFormat;
    AVAudioFrameCount lengthInFrames = (AVAudioFrameCount)audioFile.length;
    
    // Create a PCM buffer
    AVAudioPCMBuffer *buffer = [[AVAudioPCMBuffer alloc] initWithPCMFormat:format frameCapacity:lengthInFrames];
    
    // Read the file into the buffer
    NSError *readError;
    [audioFile readIntoBuffer:buffer error:&readError];
    
    if (readError) {
        NSLog(@"Error reading audio file: %@", readError);
        return @"";
    }
    
    // Convert to mono if needed and extract float samples
    float *samples = [self convertToMonoSamples:buffer originalFormat:format length:&lengthInFrames];
    
    if (samples == NULL) {
        NSLog(@"Failed to convert audio to samples");
        return @"";
    }
    
    // Transcribe the audio
    NSString *result = [self transcribeSamples:context samples:samples length:lengthInFrames sampleRate:format.sampleRate];
    
    // Clean up
    free(samples);
    
    return result;
}

// Convert buffer to mono samples
+ (float *)convertToMonoSamples:(AVAudioPCMBuffer *)buffer originalFormat:(AVAudioFormat *)format length:(AVAudioFrameCount *)length {
    AVAudioChannelCount channelCount = format.channelCount;
    *length = buffer.frameLength;
    float *samples = (float *)malloc(sizeof(float) * (*length));
    
    if (samples == NULL) {
        return NULL;
    }
    
    if (channelCount == 1) {
        // Mono audio - just copy the data
        memcpy(samples, buffer.floatChannelData[0], (*length) * sizeof(float));
    } else {
        // Convert to mono by averaging all channels
        for (AVAudioFrameCount i = 0; i < *length; i++) {
            float sum = 0.0f;
            for (AVAudioChannelCount ch = 0; ch < channelCount; ch++) {
                sum += buffer.floatChannelData[ch][i];
            }
            samples[i] = sum / channelCount;
        }
    }
    
    return samples;
}

// Transcribe audio samples
+ (NSString *)transcribeSamples:(whisper_context *)context samples:(float *)samples length:(int)length sampleRate:(double)sampleRate {
    // Prepare whisper parameters
    struct whisper_full_params wparams = whisper_full_default_params(WHISPER_SAMPLING_GREEDY);
    wparams.print_realtime = false;
    wparams.print_progress = false;
    wparams.print_timestamps = false;
    wparams.translate = false;
    wparams.language = "en";
    wparams.n_threads = MIN(8, NSProcessInfo.processInfo.activeProcessorCount); // Use multiple threads
    
    // Handle 16kHz requirement (whisper expects 16kHz audio)
    float *processedSamples;
    int processedLength;
    
    if (sampleRate != 16000.0) {
        // Resample to 16kHz
        processedLength = (int)(length * 16000.0 / sampleRate);
        processedSamples = (float *)malloc(processedLength * sizeof(float));
        
        if (!processedSamples) {
            return @"";
        }
        
        [self resampleAudio:samples length:length sampleRate:sampleRate
                toSamples:processedSamples length:processedLength targetSampleRate:16000.0];
    } else {
        // Already 16kHz
        processedSamples = samples;
        processedLength = length;
    }
    
    // Run the inference
    if (whisper_full(context, wparams, processedSamples, processedLength) != 0) {
        NSLog(@"Failed to process audio");
        
        if (processedSamples != samples) {
            free(processedSamples);
        }
        
        return @"";
    }
    
    // Get the number of segments
    int numSegments = whisper_full_n_segments(context);
    NSMutableString *resultText = [NSMutableString string];
    
    // Extract text from segments
    for (int i = 0; i < numSegments; ++i) {
        const char* text = whisper_full_get_segment_text(context, i);
        [resultText appendString:@(text)];
        
        // Add space between segments
        if (i < numSegments - 1) {
            [resultText appendString:@" "];
        }
    }
    
    // Clean up if we resampled
    if (processedSamples != samples) {
        free(processedSamples);
    }
    
    return resultText;
}

// Resample audio to target sample rate (simple linear interpolation)
+ (void)resampleAudio:(float *)input length:(int)inputLength sampleRate:(double)inputSampleRate
            toSamples:(float *)output length:(int)outputLength targetSampleRate:(double)targetSampleRate {
    
    double ratio = inputSampleRate / targetSampleRate;
    
    for (int i = 0; i < outputLength; i++) {
        double srcPos = i * ratio;
        int srcIdx = (int)srcPos;
        float frac = srcPos - srcIdx;
        
        if (srcIdx >= inputLength - 1) {
            output[i] = input[inputLength - 1];
        } else {
            output[i] = input[srcIdx] * (1.0f - frac) + input[srcIdx + 1] * frac;
        }
    }
}

// Transcribe audio from a buffer
+ (NSString *)transcribeBuffer:(whisper_context *)context buffer:(float *)buffer length:(int)length {
    if (context == NULL) {
        NSLog(@"Whisper context is NULL");
        return @"";
    }
    
    // Prepare whisper parameters
    struct whisper_full_params wparams = whisper_full_default_params(WHISPER_SAMPLING_GREEDY);
    wparams.print_realtime = false;
    wparams.print_progress = false;
    wparams.print_timestamps = false;
    wparams.translate = false;
    wparams.language = "en";
    wparams.n_threads = MIN(8, NSProcessInfo.processInfo.activeProcessorCount);
    
    // Run the inference
    if (whisper_full(context, wparams, buffer, length) != 0) {
        NSLog(@"Failed to process audio buffer");
        return @"";
    }
    
    // Get the number of segments
    int numSegments = whisper_full_n_segments(context);
    NSMutableString *resultText = [NSMutableString string];
    
    // Extract text from segments
    for (int i = 0; i < numSegments; ++i) {
        const char* text = whisper_full_get_segment_text(context, i);
        [resultText appendString:@(text)];
        
        // Add space between segments
        if (i < numSegments - 1) {
            [resultText appendString:@" "];
        }
    }
    
    return resultText;
}

@end





### ./YapNotes/Utils/ModelDownloader.swift

import Foundation
import Combine

class ModelDownloader {
    enum DownloadError: Error {
        case invalidURL
        case downloadFailed
        case fileSystemError
    }
    
    static func downloadModel(from url: URL, to destinationURL: URL, progressHandler: @escaping (Double) -> Void) -> AnyPublisher<URL, Error> {
        return Deferred {
            Future<URL, Error> { promise in
                let task = URLSession.shared.downloadTask(with: url) { tempURL, response, error in
                    // Handle errors
                    if let error = error {
                        promise(.failure(error))
                        return
                    }
                    
                    guard let tempURL = tempURL else {
                        promise(.failure(DownloadError.downloadFailed))
                        return
                    }
                    
                    do {
                        // Create directory if needed
                        let directory = destinationURL.deletingLastPathComponent()
                        try FileManager.default.createDirectory(at: directory, withIntermediateDirectories: true)
                        
                        // Remove any existing file
                        if FileManager.default.fileExists(atPath: destinationURL.path) {
                            try FileManager.default.removeItem(at: destinationURL)
                        }
                        
                        // Move downloaded file to destination
                        try FileManager.default.moveItem(at: tempURL, to: destinationURL)
                        
                        promise(.success(destinationURL))
                    } catch {
                        promise(.failure(error))
                    }
                }
                
                // Track progress
                let progressObserver = task.progress.observe(\.fractionCompleted) { progress, _ in
                    DispatchQueue.main.async {
                        progressHandler(progress.fractionCompleted)
                    }
                }
                
                // Start the download
                task.resume()
                
                // Keep progress observer alive until task completes
                _ = progressObserver
            }
        }
        .eraseToAnyPublisher()
    }
    
    static func verifyDownloadedModel(at url: URL, expectedSize: Int? = nil, checksumFunction: ((URL) -> Bool)? = nil) -> Bool {
        guard FileManager.default.fileExists(atPath: url.path) else {
            return false
        }
        
        if let expectedSize = expectedSize {
            do {
                let attributes = try FileManager.default.attributesOfItem(atPath: url.path)
                if let fileSize = attributes[.size] as? Int {
                    if fileSize < expectedSize {
                        return false
                    }
                }
            } catch {
                return false
            }
        }
        
        if let checksumFunction = checksumFunction {
            return checksumFunction(url)
        }
        
        return true
    }
}



### ./YapNotes/Utils/Extensions/Date+Extensions.swift

import Foundation

extension Date {
    func formattedString() -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        return formatter.string(from: self)
    }
    
    var isToday: Bool {
        return Calendar.current.isDateInToday(self)
    }
    
    var isYesterday: Bool {
        return Calendar.current.isDateInYesterday(self)
    }
    
    var isThisWeek: Bool {
        let calendar = Calendar.current
        let today = calendar.startOfDay(for: Date())
        let weekAgo = calendar.date(byAdding: .weekOfYear, value: -1, to: today)!
        return self > weekAgo
    }
    
    func timeAgoString() -> String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .full
        return formatter.localizedString(for: self, relativeTo: Date())
    }
    
    func sameDayAs(_ date: Date) -> Bool {
        return Calendar.current.isDate(self, inSameDayAs: date)
    }
}



### ./YapNotes/Utils/Extensions/String+Extensions.swift

import Foundation
import NaturalLanguage

extension String {
    var trimmed: String {
        return self.trimmingCharacters(in: .whitespacesAndNewlines)
    }
    
    func truncated(to length: Int, trailing: String = "...") -> String {
        if self.count > length {
            return String(self.prefix(length)) + trailing
        } else {
            return self
        }
    }
    
    func tokenized() -> [String] {
        let tagger = NLTagger(tagSchemes: [.tokenType])
        tagger.string = self
        
        var tokens: [String] = []
        
        tagger.enumerateTags(in: self.startIndex..<self.endIndex, unit: .word, scheme: .tokenType) { tag, tokenRange in
            if let tag = tag, tag == .word {
                tokens.append(String(self[tokenRange]))
            }
            return true
        }
        
        return tokens
    }
    
    func sentences() -> [String] {
        var sentences: [String] = []
        
        let range = self.startIndex..<self.endIndex
        let tagger = NLTagger(tagSchemes: [.tokenType])
        tagger.string = self
        
        tagger.enumerateTags(in: range, unit: .sentence, scheme: .tokenType) { _, sentenceRange in
            let sentence = String(self[sentenceRange])
            sentences.append(sentence)
            return true
        }
        
        return sentences
    }
    
    var localized: String {
        return NSLocalizedString(self, comment: "")
    }
}



### ./YapNotes/Utils/Extensions/URL+Extensions.swift

import Foundation

extension URL {
    var isAudioFile: Bool {
        let audioExtensions = ["m4a", "mp3", "wav", "aac"]
        return audioExtensions.contains(self.pathExtension.lowercased())
    }
    
    var creationDate: Date? {
        let attributes = try? FileManager.default.attributesOfItem(atPath: self.path)
        return attributes?[.creationDate] as? Date
    }
    
    var fileSize: Int64 {
        let attributes = try? FileManager.default.attributesOfItem(atPath: self.path)
        return (attributes?[.size] as? NSNumber)?.int64Value ?? 0
    }
    
    var formattedFileSize: String {
        let bytes = Double(fileSize)
        let kb = bytes / 1024
        let mb = kb / 1024
        
        if mb >= 1.0 {
            return String(format: "%.1f MB", mb)
        } else if kb >= 1.0 {
            return String(format: "%.1f KB", kb)
        } else {
            return String(format: "%.0f bytes", bytes)
        }
    }
    
    var fileName: String {
        return self.deletingPathExtension().lastPathComponent
    }
}




To complete the integration with Whisper.cpp, you'll need to add the Whisper.cpp repository as a submodule or download it directly. Here's how to integrate it:


### ./YapNotes/Services/Whisper/whisper.cpp/README.md

This is a placeholder for the Whisper.cpp repository. You should:

1. Add the Whisper.cpp repository as a git submodule:
   git submodule add https://github.com/ggerganov/whisper.cpp.git YapNotes/Services/Whisper/whisper.cpp

2. Or download the repository directly and place it in this directory.

The key files needed are:
- whisper.h - The main header file
- whisper.cpp - The implementation file
- ggml.h - Supporting tensor library header
- ggml.c - Supporting tensor library implementation

You'll also need to configure the Xcode project to include these C/C++ files in the build.




For proper project configuration:


### ./YapNotes/Info.plist

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDevelopmentRegion</key>
    <string>$(DEVELOPMENT_LANGUAGE)</string>
    <key>CFBundleExecutable</key>
    <string>$(EXECUTABLE_NAME)</string>
    <key>CFBundleIdentifier</key>
    <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>$(PRODUCT_NAME)</string>
    <key>CFBundlePackageType</key>
    <string>$(PRODUCT_BUNDLE_PACKAGE_TYPE)</string>
    <key>CFBundleShortVersionString</key>
    <string>1.0</string>
    <key>CFBundleVersion</key>
    <string>1</string>
    <key>LSRequiresIPhoneOS</key>
    <true/>
    <key>NSMicrophoneUsageDescription</key>
    <string>YapNotes needs access to your microphone to record your thoughts.</string>
    <key>NSSpeechRecognitionUsageDescription</key>
    <string>YapNotes uses speech recognition to transcribe your thoughts.</string>
    <key>UIApplicationSceneManifest</key>
    <dict>
        <key>UIApplicationSupportsMultipleScenes</key>
        <false/>
    </dict>
    <key>UIApplicationSupportsIndirectInputEvents</key>
    <true/>
    <key>UILaunchScreen</key>
    <dict/>
    <key>UIRequiredDeviceCapabilities</key>
    <array>
        <string>armv7</string>
    </array>
    <key>UISupportedInterfaceOrientations</key>
    <array>
        <string>UIInterfaceOrientationPortrait</string>
    </array>
    <key>UISupportedInterfaceOrientations~ipad</key>
    <array>
        <string>UIInterfaceOrientationPortrait</string>
        <string>UIInterfaceOrientationPortraitUpsideDown</string>
        <string>UIInterfaceOrientationLandscapeLeft</string>
        <string>UIInterfaceOrientationLandscapeRight</string>
    </array>
</dict>
</plist>